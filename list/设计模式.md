# 设计模式

> 'https://www.jianshu.com/p/7deb64f902db'

## 设计原则

### 单一职责原则

* 一个类应该只有一个引起它变化的原因。
* 如果一个类承担的职责过多，即耦合性太高。那么一个职责的变化可能会影响到其他的职责

### 开放封闭原则

* 一个实体（类、函数、模块等）应该对外扩展开放，对内修改关闭
* 即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。
* 符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。

### 里氏替换原则

* 子类必须替换掉它们的父类型。
* 在软件开发过程中，子类替换父类后，程序的行为是一样的。
* 只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。

### 依赖倒置原则

* 细节应该依赖于抽象，而抽象不应该依赖于细节。
* 所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。

### 接口隔离原则

* 使用多个专门功能的接口，而不是使用单一的总接口。
* 不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。

### 合成复用原则

* 在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。
* 新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

### 最少知识原则（迪米特法则）

* 一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更容易。
* 关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟 “陌生人” 说话。
* 外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。

## 创建型模式

### 工厂模式

#### 工厂模式-描述

> 虚拟构造函数、Virtual Constructor、Factory Method

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

#### 工厂模式-场景

> 不关心对象实现细节及其依赖关系时，可使用工厂方法。

`理解` 比如你要一台电脑，如果自己买回所有零件自己组装将会是一件非常痛苦的事情，这个复杂的事情交给工厂去做就可以了。所以工厂模式的本质就是封装复杂事物，提供简单接口

#### 工厂模式-实现

* `Product` 抽象产品，定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口
* `ConcreteProduct` 具体产品，Product 接口的实现对象
* `Factory` 工厂接口，也可以叫 Creator(创建器)，申明工厂方法，通常返回一个 Product 类型的实例对象
* `ConcreteFactory` 工厂实现，或者叫 ConcreteCreator(创建器对象)，覆盖 Factory 定义的工厂方法，返回具体的 Product 实例

```ts
// 产品的抽象接口
interface Product {
  operation(): string;
}

// 工厂（抽象类）
abstract class Factory {
  // 创建实例对象（抽象方法）
  public abstract factoryMethod(): Product;

  public someOperation(): string {
    const product = this.factoryMethod();
    return `Creator: The same creator's code has just worked with ${product.operation()}`;
  }
}

// 产品的实现方法
class ConcreteProduct implements Product {
  operation(): string {
    return 'I\'M Product';
  }
}

// 工厂的实现方法
class ConcreteFactory extends Factory {
  // 覆盖工厂的创建方法
  public factoryMethod(): Product {
    return new ConcreteProduct();
  }
}

// 使用工厂暴露的接口实现某些功能
const newFactory = new ConcreteFactory();

const result = newFactory.someOperation();

console.log(result);
```

#### 工厂模式-优点

* 你可以避免创建者和具体产品之间的紧密耦合。
* 开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。
* 单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。

#### 工厂模式-缺点

* 一个具体工厂只能创建一类产品
* 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的原有结构中。

### 抽象工厂模式

#### 抽象工厂模式-描述

抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品

#### 抽象工厂模式-场景

创建多类商品

#### 抽象工厂模式-实现

* `Creator` 具体工厂的父类，描述具体工厂的公共接口
* `Product` 具体产品的父类，描述具体产品的公共接口
* `AbstractProduct` 抽象产品的父类，描述抽象产品的公共接口
* `ConcreteProduct` 抽象产品的子类；工厂类创建的目标类，描述生产的具体产品
* `ConcreteCreator` 抽象工厂的子类；被外界调用，描述具体工厂；实现FactoryMethod工厂方法创建产品的实例

```ts
/**
 * The Abstract Factory interface declares a set of methods that return
 * different abstract products. These products are called a family and are
 * related by a high-level theme or concept. Products of one family are usually
 * able to collaborate among themselves. A family of products may have several
 * variants, but the products of one variant are incompatible with products of
 * another.
 */
interface AbstractFactory {
  createProductA(): AbstractProductA;

  createProductB(): AbstractProductB;
}

/**
* Concrete Factories produce a family of products that belong to a single
* variant. The factory guarantees that resulting products are compatible. Note
* that signatures of the Concrete Factory's methods return an abstract product,
* while inside the method a concrete product is instantiated.
*/
class ConcreteFactory1 implements AbstractFactory {
  public createProductA(): AbstractProductA {
      return new ConcreteProductA1();
  }

  public createProductB(): AbstractProductB {
      return new ConcreteProductB1();
  }
}

/**
* Each Concrete Factory has a corresponding product variant.
*/
class ConcreteFactory2 implements AbstractFactory {
  public createProductA(): AbstractProductA {
      return new ConcreteProductA2();
  }

  public createProductB(): AbstractProductB {
      return new ConcreteProductB2();
  }
}

/**
* Each distinct product of a product family should have a base interface. All
* variants of the product must implement this interface.
*/
interface AbstractProductA {
  usefulFunctionA(): string;
}

/**
* These Concrete Products are created by corresponding Concrete Factories.
*/
class ConcreteProductA1 implements AbstractProductA {
  public usefulFunctionA(): string {
      return 'The result of the product A1.';
  }
}

class ConcreteProductA2 implements AbstractProductA {
  public usefulFunctionA(): string {
      return 'The result of the product A2.';
  }
}

/**
* Here's the the base interface of another product. All products can interact
* with each other, but proper interaction is possible only between products of
* the same concrete variant.
*/
interface AbstractProductB {
  /**
   * Product B is able to do its own thing...
   */
  usefulFunctionB(): string;

  /**
   * ...but it also can collaborate with the ProductA.
   *
   * The Abstract Factory makes sure that all products it creates are of the
   * same variant and thus, compatible.
   */
  anotherUsefulFunctionB(collaborator: AbstractProductA): string;
}

/**
* These Concrete Products are created by corresponding Concrete Factories.
*/
class ConcreteProductB1 implements AbstractProductB {

  public usefulFunctionB(): string {
      return 'The result of the product B1.';
  }

  /**
   * The variant, Product B1, is only able to work correctly with the variant,
   * Product A1. Nevertheless, it accepts any instance of AbstractProductA as
   * an argument.
   */
  public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
      const result = collaborator.usefulFunctionA();
      return `The result of the B1 collaborating with the (${result})`;
  }
}

class ConcreteProductB2 implements AbstractProductB {

  public usefulFunctionB(): string {
      return 'The result of the product B2.';
  }

  /**
   * The variant, Product B2, is only able to work correctly with the variant,
   * Product A2. Nevertheless, it accepts any instance of AbstractProductA as
   * an argument.
   */
  public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
      const result = collaborator.usefulFunctionA();
      return `The result of the B2 collaborating with the (${result})`;
  }
}

/**
* The client code works with factories and products only through abstract
* types: AbstractFactory and AbstractProduct. This lets you pass any factory or
* product subclass to the client code without breaking it.
*/
function clientCode(factory: AbstractFactory) {
  const productA = factory.createProductA();
  const productB = factory.createProductB();

  console.log(productB.usefulFunctionB());
  console.log(productB.anotherUsefulFunctionB(productA));
}

/**
* The client code can work with any concrete factory class.
*/
console.log('Client: Testing client code with the first factory type...');
clientCode(new ConcreteFactory1());

console.log('');

console.log('Client: Testing the same client code with the second factory type...');
clientCode(new ConcreteFactory2());
```

### 生成器模式

生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。
当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。

### 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。
我们举个例子：如果我们已经有了一个String[]数组，想再创建一个一模一样的String[]数组，怎么写？
实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。

### 结构型模式
