# JavaScript —— 基于原型的面向对象

> 原型（Prototype），是一种设计模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。

## 常见编程范式

**面向过程编程（POP - procedure oriented Programming）** 面向过程就是分析出解决问题所需要的步骤，使用时在调用函数实现步骤和流程。

**面向对象编程（OOP - object-oriented programming）** 是相对于面向过程编程来讲的，以面向对象的方式，会把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

**函数式编程（FP - functional programming）** 是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法。为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。

## 原型与原型链

> `__proto__` 是任何对象都有的属性，在js中会形成一条 `__proto__` 连起来的链条，最终会被指向顶级 Object 对象，并且 Object.prototype 的值为 null。

- prototype：此属性只有构造函数才有，它指向的是当前构造函数的原型对象。
- __proto__：此属性是任何对象都会有的一个属性，它指向了产生当前对象的构造函数的原型对象。

```javascript
// 构造函数
function Person(name, gender) {
  this.name = name;
  this.gender = gender;
}

Person.prototype.age = 0;

Person.prototype.callme = function () {
  console.log(this.name + ' calling...');
}

// 对象实例化
var chogath = new Person('chogath', 'boy');
var lux = new Person('lux', 'girl');

console.log(chogath.name); // chogath
console.log(chogath.gender); // boy
chogath.callme(); // chogath calling...

lux.age = 16;
console.log(lux.age); // 16
console.log(Person.prototype.age) // 0
```

![1](../../assets/image/proto.png)


## this 指针

### 函数调用
JS（ES5）里面有三种函数调用形式：

```javascript
func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 这里先不讲 apply
```

第一种与第二种本质上都是语法糖，可以等价的变为`call`形式。

`func(p1, p2)等价于 func.call(undefined, p1, p2);`

`obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);`

这么看我们的函数调用只有一种形式:

```javascript
func.call(context,p1,p2)
```

如果是在浏览器中，默认的 this 就是 window 对象；如果是在 Node.js 环境中默认的 this 就是 global 对象。

最终，在浏览器中运行结果为 5；在 Node.js 环境中为 undefined。

#### Node.js 环境下指向全局的this关键字说明(你可能不知道)
为什么在浏览器或者前端环境可以直接正常输出值，而在 Node.js 环境中输出的却是`undefined`。
看一下这段代码你可能就懂了。

```javascript
(function(exports, require, module, __filename, __dirname) {
    {
    // 模块的代码
    // 所以那整个代码应该在这里吧
    var a = 10;
    function A(){
        a = 5;
        console.log(a);
        console.log(this.a);
    }
    // const haha = new A();
    A();
    }
});
```

先说一下 Node.js 环境下在运行某个 js 模块代码时候发生了什么，Node.js 在执行代码之前会使用一个代码封装器进行封装，例如下面所示：

```javascript
(function(exports, require, module, __filename, __dirname) {
    {
    // 模块的代码
    // 所以那整个代码应该在这里吧
    }
});
```

这段代码在 Node.js 环境下输出结果为`5，undefined`是不是就能理解了。

这里面的this是默认绑定指向全局，当输出this.a的时候，全局应该指向这个闭包的最外层。所以输出结果式是undefined。

#### [] 语法中的this关键字

```javascript
function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？ 
```

我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：

```
         arr[0]() 
假想为    arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了
```
### 绑定原则

#### 默认绑定

默认绑定是函数针对的独立调用的时候，不带任何修饰的函数引用进行调用，非严格模式下 this 指向全局对象(浏览器下指向 Window，Node.js 环境是 Global ），严格模式下，this 绑定到 undefined ,严格模式不允许this指向全局对象。

```javascript
var a = 'hello'

var obj = {
    a: 'chogath',
    foo: function() {
        console.log(this.a)
    }
}

var bar = obj.foo

bar()              // 浏览器中输出: "hello"
```

这段代码，`bar()`就是默认绑定，函数调用的时候，前面没有任何修饰调用，也可以用之前的 `call`函数调用形式理解，所以输出结果是`hello`。

##### 默认绑定的另一种情况

在函数中以函数作为参数传递，例如`setTimeOut`和`setInterval`等，这些函数中传递的函数中的`this`指向，在非严格模式指向的是全局对象。

例子：

```javascript
var name = 'chogath';
var person = {
    name: 'lux',
    sayHi: sayHi
}
function sayHi(){
    setTimeout(function(){
        console.log('Hello,', this.name);
    })
}
person.sayHi();
setTimeout(function(){
    person.sayHi();
},200);
// 输出结果 Hello,chogath
// 输出结果 Hello,chogath
```

#### 隐式绑定

判断 this 隐式绑定的基本标准:函数调用的时候是否在上下文中调用，或者说是否某个对象调用函数。

例子:
```javascript
var a = 'chogath'

var obj = {
    a: 'lux',
    foo: function() {
        console.log(this.a)
    }
}
obj.foo()       // 浏览器中输出: "lux"
```
foo 方法是作为对象的属性调用的，那么此时 foo 方法执行时，this 指向 obj 对象。

**隐式绑定的另一种情况**

当有多层对象嵌套调用某个函数的时候，如 `对象.对象.函数`, this 指向的是最后一层对象。

例子:

```javascript
function sayHi(){
    console.log('Hello,', this.name);
}
var person2 = {
    name: 'lux',
    sayHi: sayHi
}
var person1 = {
    name: 'chogath',
    friend: person2
}
person1.friend.sayHi();

// 输出结果为 Hello, lux
```

看完这个例子，是不是也就懂了隐式调用的这种情况。

#### 显式绑定
显式绑定，通过函数call apply bind 可以修改函数this的指向。call 与 apply 方法都是挂载在 Function 原型下的方法，所有的函数都能使用。

#### call 和 apply 的区别

1. call和apply的第一个参数会绑定到函数体的this上，如果`不传参数`，例如`fun.call()`，非严格模式，this默认还是绑定到全局对象
2. call函数接收的是一个参数列表，apply函数接收的是一个参数数组。

```javascript
unc.call(thisArg, arg1, arg2, ...)        // call 用法
func.apply(thisArg, [arg1, arg2, ...])     // apply 用法
```

看代码例子:

```javascript
var person = {
    "name": "chogath"
};
function changeJob(company, work) {
    this.company = company;
    this.work    = work;
};

changeJob.call(person, '百度', '程序员');
console.log(person.work); // '程序员'

changeJob.apply(person, ['百度', '测试']);
console.log(person.work); // '测试'
```

#### call和apply的注意点

这两个方法在调用的时候，如果我们传入数字或者字符串，这两个方法会把传入的参数转成对象类型。

例子:

```javascript
var number = 1, string = 'lux';
function getThisType () {
    var number = 3;
    console.log('this指向内容',this);
    console.log(typeof this);
}
getThisType.call(number);
getThisType.apply(string); 
// 输出结果
// this指向内容 [Number: 1]
// object
// this指向内容 [String: 'lux']
// object
```

#### bind函数

> bind 方法

会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(定义内容来自于 MDN )

```javascript
func.bind(thisArg[, arg1[, arg2[, ...]]])    // bind 用法
```
例子:
```javascript
var publicAccounts = {
    name: 'lux',
    author: 'chogath',
    subscribe: function(subscriber) {
        console.log(subscriber + this.name)
    }
}

publicAccounts.subscribe('小红')   // 输出结果: "小红 lux"

var subscribe1 = publicAccounts.subscribe.bind({ name: 'Node成长指北', author: '考拉' }, '小明 ')
subscribe1()       // 输出结果: "小明 Node成长指北"
```

#### new 绑定

使用new调用函数的时候，会执行怎样的流程：

1. 创建一个空对象
2. 将空对象的 _proto_ 指向原对象的 prototype
3. `执行构造函数中的代码`
4. 返回这个新对象

例子:

```javascript
function study(name){
    this.name = name;
	
}
var studyDay = new study('chogath');
console.log(studyDay);
console.log('Hello,', studyDay.name);
// 输出结果
// study { name: 'chogath' }
// hello，chogath
```

在`new study('chogath')`的时候，会改变this指向，将`this指向指定到了studyDay对象`。

注意:如果创建新的对象，构造函数不传值的话，新对象中的属性不会有值，但是新的对象中会有这个属性。

#### 手动实现一个new创建对象代码(多种实现方式哦)
```javascript
function New(func) {
    var res = {};
    if (func.prototype !== null) {
        res.__proto__ = func.prototype;
    }
    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
    if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
        return ret;
    }
    return res;
}
var obj = New(A, 1, 2);
// equals to
var obj = new A(1, 2);
```

### 绑定优先级

上面介绍了 this 的四种绑定规则，但是一段代码有时候会同时应用多种规则，这时候 this 应该如何指向呢？其实它们也是有一个先后顺序的，具体规则如下:

**new绑定 > 显式绑定 > 隐式绑定 > 默认绑定**

### 箭头函数中的 this

#### 箭头函数

- 箭头函数中没有 arguments

常规函数可以直接拿到 arguments 属性，但是在箭头函数中如果使用 arguments 属性，拿到的是箭头函数外层函数的 arguments 属性。

例子:
```javascript
function constant() {
    return () => arguments[0]
}

let result = constant(1);
console.log(result()); // 1
```
**如果我们就是要访问箭头函数的参数呢？**

你可以通过 ES6 中 命名参数 或者 rest 参数的形式访问参数
```javascript
let nums = (...nums) => nums;
```
- 箭头函数没有构造函数

箭头函数与正常的函数不同，箭头函数没有构造函数 constructor，因为没有构造函数，所以也不能使用 new 来调用，如果我们直接使用 new 调用箭头函数，会报错。

例子:
```javascript
let fun = ()=>{}
let funNew = new fun(); 
// 报错内容 TypeError: fun is not a constructor
```
- 箭头函数没有原型

原型 prototype 是函数的一个属性，但是对于箭头函数没有它。

例子:
```javascript
let fun = ()=>{}
console.loh(fun.prototype); // undefined
```
- 箭头函数中没有 super

上面说了没有原型，连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。

- `箭头函数中没有自己的this`

箭头函数中没有自己的 this，箭头函数中的 this 不能用 call()、apply()、bind() 这些方法改变 this 的指向，箭头函数中的 this 直接指向的是`调用函数的 上一层运行时`。

```javascript
let a = 'chogath'

let obj = {
    a: 'lux',
    foo: () => {
        console.log(this.a)
    }
}

obj.foo()             // 输出结果: "chogath"
```

看完输出结果，怕大家有疑问还是分析一下，前面我说的箭头函数中this直接指向的是`调用函数的上一层运行时`，这段代码`obj.foo`在调用的时候如果是不使用箭头函数this应该指向的是 obj ，但是使用了箭头函数，往上一层查找，指向的就是全局了，所以输出结果是`chogath`。

## 面向对象的实现

> 面向对象 (Object Oriented) 是软件开发方法，一种编程范式，是一种对现实世界理解和抽象的方法。

- `封装`：把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。
- `继承`：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。
- `多态`：同一个操作作用于不同的对象上，可以产生不同的解释和不同的执行结果。

> Javascript是一种基于对象（object-based）的语言。但是，它又不是一种完整的面向对象编程语言，因为 es6 前它的语法中没有 class（类）。

### 封装

#### 通过构造函数生成

> javascript提供了一个构造函数（Constructor）模式，用来在创建对象时初始化对象。构造函数其实就是普通的函数，只不过有以下特点
> 
> 1. 首字母大写（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）
> 2. 内部使用this
> 3. 使用 new生成实例
> 4. 通过 this 定义的属性和方法，我们每次实例化对象的时候都会重新复制一份

**使用 this 指定属性**

```javascript
function Cat(name) {
  this.name = name;
  this.eat = function() {
    console.log('吃老鼠');
  };
};

var cat = new Cat('tom');
```

**通过原型 prototype 添加属性**

```javascript
function Cat(name) {}

Cat.prototype.name = 'tom';
Cat.prototype.eat = function() {
  console.log('吃老鼠');
};
```

#### 通过 es6 中的 class 关键字

> 在ES6中，class (类) 作为对象的模板被引入，可以通过 class 关键字定义类。class 的本质还是构造函数，它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。
> 
> 1. 类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。
> 2. 类中方法不需要 function 关键字。
> 3. 方法间不能加分号。

```javascript
class Cat {
  constructor(name) {
    this.name = name;
  }

  // 原型方法
  eat() {
    console.log('吃老鼠');
  }
}

var cat = new Cat('tom');
```

**constructor**

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

```javascript
class Example{
  constructor(){
    console.log('我是constructor');
  }
}
new Example(); // 我是constructor
```

实例方法：

```javascript
class Example {
  constructor() {
    this.sum = (a, b) => {
      console.log(a + b);
    }
  }
}
```
**static**

静态属性（es7 实现）：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。

```javascript
class Example {
  static a = 2;
}
```

静态方法（es6 实现）：

```javascript
class Example{
  static sum(a, b) {
    console.log(a+b);
  }
}
Example.sum(1, 2); // 3
```

**prototype**

ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法。

**getter / setter**

```javascript
class Person {
  constructor (name, age) {
    this.name = name;
    this.age = age;
  }
  set name (name) {
    console.log("setter");
    this._name = name;
  }
  get name () {
    console.log("getter");
    return this._name;
  }

  // 加一个成员方法
  sayName () {
    console.log(this.name);
  }
}

var p = new Person("zhang", 25);

p.sayName();
```

### 继承

#### 原型继承

> 原型继承就是指使用原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。

举个 🌰

```javascript
// 声明父类
const SuperClass = function () {
  const id = 1;
  this.name = ['javascript'];
  this.superValue = function () {
    console.log('superValue is true');
    console.log(id);
  };
};

// 声明子类
const SubClass = function () {
  this.subValue = function () {
    console.log('this is subValue ');
  };
};

// 继承父类
SubClass.prototype = new SuperClass();

var sub = new SubClass();
var sub2 = new SubClass();

console.log(sub.id);    // undefined
console.log(sub.name);  // ["javascript"]

sub.name.push('java');

console.log(sub2.name)  // ["javascript", "java"]
```

**注意**：如上述代码的最后一段，使用原型继承的方法，如果父类的属性中有引用类型，就会在子类中被所有实例共用，因此一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例。

#### 构造函数继承

> 构造函数继承的核心思想就是 SuperClass.call(this, id)，直接改变 this 的指向，使通过 this 创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费。

```javascript
// 声明父类
function SuperClass(id) {
  const name = 'javascript';
  this.books = ['javascript', 'html', 'css'];
  this.id = id;
}

// 声明父类原型方法
SuperClass.prototype.showBooks = function () {
  console.log(this.books);
};

// 声明子类
function SubClass(id) {
  SuperClass.call(this, id);
}

// 创建第一个子类实例
const subclass1 = new SubClass(10);
const subclass2 = new SubClass(11);

console.log(subclass1.books);
console.log(subclass2.id);
console.log(subclass1.name); // undefined
subclass2.showBooks();
```

#### 组合式继承

> 原型继承 + 构造函数继承（.call）组合式继承的方法固然好，但是会导致一个问题，父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍）

```javascript
// 声明父类
const SuperClass = function (name) {
  this.name = name;
  this.books = ['javascript', 'html', 'css'];
};
// 声明父类原型上的方法
SuperClass.prototype.showBooks = function () {
  console.log(this.books);
};

// 声明子类
const SubClass = function (name) {
  SuperClass.call(this, name);
};

// 子类继承父类（链式继承）
SubClass.prototype = new SuperClass();

// 实例化子类
const subclass1 = new SubClass('java');
const subclass2 = new SubClass('php');
subclass2.showBooks();
subclass1.books.push('ios'); // ["javascript", "html", "css"]
console.log(subclass1.books); // ["javascript", "html", "css", "ios"]
console.log(subclass2.books); // ["javascript", "html", "css"]
```

#### 寄生组合式继承

```javascript
// 原型式继承
// 原型式继承其实就是类式继承的封装,实现的功能是返回一个实例，改实例的原型继承了传入的o对象
function inheritObject(o) {
  // 声明一个过渡函数对象
  function F() {}
  // 过渡对象的原型继承父对象
  F.prototype = o;
  // 返回一个过渡对象的实例，该实例的原型继承了父对象
  return new F();
}

// 寄生式继承
// 寄生式继承就是对原型继承的第二次封装，使得子类的原型等于父类的原型。并且在第二次封装的过程中对继承的对象进行了扩展
function inheritPrototype(subClass, superClass) {
  // 复制一份父类的原型保存在变量中，使得p的原型等于父类的原型
  const p = inheritObject(superClass.prototype);
  // 修正因为重写子类原型导致子类constructor属性被修改
  p.constructor = subClass;
  // 设置子类的原型
  subClass.prototype = p;
}
// 定义父类
const SuperClass = function (name) {
  this.name = name;
  this.books = ['javascript', 'html', 'css'];
};
  // 定义父类原型方法
SuperClass.prototype.getBooks = function () {
  console.log(this.books);
};

// 定义子类
const SubClass = function (name) {
  SuperClass.call(this, name);
};

inheritObject(SubClass, SuperClass);

const subclass1 = new SubClass('php');
```

#### es6 class 继承

> ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
> 
> ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

**extents**

通过 extends 实现类的继承。

```javascript
class Point {
}

class ColorPoint extends Point {
}
```

**super**

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。

```javascript
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

### 多态

多态最常见的2种实现方式：

- 覆盖
- 重载

覆盖指子类重新定义父类方法，这正好就是基于 prototype 继承的玩法。

重载是指多个同名但参数不同的方法，这个 JavaScript 确实没有。所以多态还是可以实现的，只不过重载在 JavaScript 中没有实际对应的语法概念，你得绕个很大的弯子来实现。

### new 原理

```javascript
var obj = new Object();
```
1. 新建一个对象o
2. `obj`.`__proto__` = **Object.prototype** 将新创建的对象的 `__proto__` 属性指向构造函数的 **prototype**
3. 将 **this** 指向新创建的对象
4. 返回新对象，但是这里需要看构造函数有没有返回值，如果构造函数的返回值为基本数据类型 **string**, **boolean**, **number**, **null**, **undefined** 那么就返回新对象，如果构造函数的返回值为对象类型，那么就返回这个对象类型
