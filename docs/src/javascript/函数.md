# JavaScript 中的高阶函数

> 高阶函数其实就是一个**接收函数作为参数**或者**将函数作为返回输出**的函数。

## 实现一个简单的高阶函数

```javascript
function add(param1, param2, fun) {
  return fun(param1) + fun(param2);
}

var x = add(-5, 6, Math.abs);
console.log(x);  // 11
```

实际的运算过程

```javascript
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

## Array 内置函数

### map

> map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

```javascript
const array1 = [1, 4, 9, 16];
const map1 = array1.map(x => x * 2);
console.log(map1); // [2, 8, 18, 32]

function pow(x) {
  return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow);
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]

```

> 语法：array.map(function(currentValue, index, array), thisArg)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|生成新数组元素的函数|
|function.currentValue|是|数组中当前正在处理的元素。|
|function.index|可选|正在处理的元素在数组中的索引。|
|function.array|可选|调用了 map 的数组本身。|
|thisArg|可选|执行 function 时，用于指定 this 指针。|

### filter

> filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6);
console.log(result); // expected output: Array ["exuberant", "destruction", "present"]
```

> 语法：arr.filter(function(currentValue, index, array), thisArg)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。|
|function.currentValue|是|数组中当前正在处理的元素。|
|function.index|可选|正在处理的元素在数组中的索引。|
|function.array|可选|调用了 filter 的数组本身。|
|thisArg|可选|执行 function 时，用于指定 this 指针。|

### reduce

> reduce() 方法对数组中的每个元素执行一个自定义的reducer函数(升序执行)，将其结果汇总为单个返回值。

```javascript
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;
// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer)); // expected output: 10
// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5)); // expected output: 15
```

```javascript
var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// reduce() 没有初始值
[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN
[ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22
[ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }
[                                ].reduce( maxCallback ); // TypeError

// map/reduce; 这是更好的方案，即使传入空数组或更大数组也可正常执行
[ { x: 22 }, { x: 42 } ].map( el => el.x )
                        .reduce( maxCallback2, -Infinity );
```

> 语法：arr.reduce(function(accumulator, currentValue, index, array), initialValue)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|执行数组中每个值的函数|
|function.accumulator|是|累加器累加回调的返回值，它是上一次调用回调时返回的累积值，或initialValue|
|function.currentValue|是|数组中正在处理的元素。|
|function.currentIndex|可选| 可选，数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。|
|function.array|可选|调用了 reduce 的数组本身。|
|initialValue|可选|可选，用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错|

#### 一些实用的 demo

> 按属性分类

```javascript
var people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 }
];

function groupBy(objectArray, property) {
  return objectArray.reduce(function (acc, obj) {
    var key = obj[property];
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(obj);
    return acc;
  }, {});
}

var groupedPeople = groupBy(people, 'age');
// groupedPeople is:
// {
//   20: [
//     { name: 'Max', age: 20 },
//     { name: 'Jane', age: 20 }
//   ],
//   21: [{ name: 'Alice', age: 21 }]
// }
```

> 将二维数组转化为一维

```javascript
var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
  function(a, b) {
    return a.concat(b);
  },
  []
);
// flattened is [0, 1, 2, 3, 4, 5]
```


### sort

> sort() 方法用原地算法对数组的元素进行排序，并返回数组，该排序方法会在原数组上直接进行排序，并不会生成一个排好序的新数组。默认排序顺序是根据 **字符串Unicode码点**。**由于它取决于具体实现，因此无法保证排序的时间和空间复杂性**。

```javascript
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();
console.log(months);
// expected output: Array ["Dec", "Feb", "Jan", "March"]

const array1 = [1, 30, 4, 21, 100000];
array1.sort();
console.log(array1);
// expected output: Array [1, 100000, 21, 30, 4]
```

> 语法 arr.sort([compareFunction])

|参数|必须|介绍|
|:-:|:-:|:-:|
|compareFunction|可选|指定按某种顺序进行排列的函数|
|function.firstEl|是|第一个用于比较的元素。|
|function.secondEl|是|第二个用于比较的元素。|

> 使用默认的 sort 函数时，底层只有两种排序： **InsertionSort** 和 **QuickSort**，数量小于等于22的数组使用 InsertionSort，比22大的数组则使用 QuickSort
> 
> [点我看源码](https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js)

```
// In-place QuickSort algorithm.
// For short (length <= 22) arrays, insertion sort is used for efficiency.
```

## 注意 callback 的可选参数

> 以 map 为例

```javascript
["1", "2", "3"].map(parseInt); // 不输出 [1,2,3]，而是输出 [1,NaN,NaN]

parseInt("1",0); // 上面说过第二个参数为进制，所以"1"，radix为0上面提到过，会忽略，根据string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数1。
parseInt("2",1); // 此时将2转为1进制数，由于超过进制数1，所以返回NaN。
parseInt("3",2); // 此时将3转为2进制数，由于超过进制数1，所以返回NaN。
```

导致这个问题的原因是 **parseInt** 有两个参数，**string** 和 **radix**(进制)。

通常我们使用时，会忽略第二个参数 **radix**，因为当 **radix** 为 0 或者不传的时候，**parseInt()** 会根据 **string** 来自动处理:

- 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
- 如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。
- 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。


## 注意 callback 的返回值

> 以 map 为例

```javascript
// 需要 return 值，否则会出现所有项置为 为 undefined

const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item => {});

console.log(arr2);
// [ undefined, undefined, undefined, undefined ]
console.log(arr1);
// [1, 2, 3, 4]
```