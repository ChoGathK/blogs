# JavaScript 中的函数和作用域

## 函数

> JavaScript 函数是被设计为执行特定任务的代码块，函数会在调用时被执行。在其他编程语言中，函数近似程序（Procedure）或子程序（Subroutine）

### 通过 function 关键词定义

> 函数构成

- `函数名`：可包含字母、数字、下划线和美元符号（规则与变量名相同）。
- `参数`：圆括号用于定义函数需要的参数 (参数 1, 参数 2, ...)
- `需要执行的代码`：由函数执行的代码被放置在花括号中 `{}` 函数中，参数和花括号内的变量被包裹在 `局部作用域` 中

```javascript
function func(param1, param2, param3) {
  // 要执行的代码
}
```

### 匿名函数

> 简单来说，就是没有名字的函数，但是匿名函数不能独立执行，需要特殊处理

```javascript
function () {
  // 要执行的代码
} // SyntaxError: Function statements require a function name
```

场景一：自执行函数

```javascript
(function (){
  console.log("test");
})(); // test
```

场景二：作为函数的返回值
```javascript
function func() {
  return function (){
    console.log("test");
  }
}
func()(); // test
```

场景三：为变量赋值 
```javascript
var func = function (){
  console.log("test");
}

func(); // test
```

### 箭头函数（=>）

> ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

```javascript
x => x * x

// 等价于
function (x) {
  return x * x;
}
```

箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连 **{ ... }** 和 **return** 都省略掉了。还有一种可以包含多条语句，这时候就不能省略 **{ ... }** 和 **return**

```javascript
x => {
  if (x > 0) {
    return x * x;
  }
  else {
    return - x * x;
  }
}
```

如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

```javascript
// SyntaxError:
x => { foo: x }

// ok:
x => ({ foo: x })
```

**对 this 指针的优化**

箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。

回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：

```javascript
var obj = {
  birth: 1990,
  getAge: function () {
    var b = this.birth; // 1990
    var fn = function () {
      return new Date().getFullYear() - this.birth; // this undefined
    };
    return fn();
  }
};
```

现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：

```javascript
var obj = {
  birth: 1990,
  getAge: function () {
    var b = this.birth; // 1990
    var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
    return fn();
  }
};
obj.getAge(); // 25
```

由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：

```javascript
var obj = {
  birth: 1990,
  getAge: function (year) {
    var b = this.birth; // 1990
    var fn = (y) => y - this.birth; // this.birth仍是1990
    return fn.call({birth:2000}, year);
  }
};
obj.getAge(2015); // 25
```


### 形参与实参

> 一般情况下，函数的形参和实参数量应该相同，但是 JavaScript 并没有要求形参和实参必须相同。在特殊情况下，函数的形参和实参数量可以不相同。

- 形参：在定义函数时，声明的参数变量仅在函数内部可见。
- 实参：在调用函数时，实际传入的值。

🌰 ① 正常的形参和实参

```javascript
function f(a, b) {  // 设置形参a和b
  return a + b;
}
var x = 1, y = 2;  // 声明并初始化变量
console.log(f(x,y));  // 调用函数并传递实参
```

🌰 ② 如果函数实参数量少于形参数量，那么多出来的形参的值默认为 undefined。

```javascript
(function (a,b) {  //定义函数，包含两个形参
  console.log(typeof a);  // 返回number
  console.log(typeof b);  // 返回undefined
})(1);  //调用函数，传递一个实参
```

🌰 ③ 如果函数实参数量多于形参数量，那么多出来的实参就不能够通过形参进行访问，函数会忽略掉多于的实参。在这个示例中，实参 3 和 4 就被忽略掉了。

```javascript
(function (a,b) {  //定义函数，包含两个形参
    console.log(a);  //返回1
    console.log(b);  //返回2
})(1,2,3,4);  //调用函数，传入四个实参值
```

## 作用域

> 作用域（scope），是一个程序设计概念。通常来说，一段程序代码中所用到的变量并不总是有效或者可用的，而限定这个变量的可用性的代码范围就是这个名字的作用域

### 全局作用域

> 函数之外声明的变量，或未定义直接赋值的变量（由于变量提升变成了全局变量），都会成为全局变量。全局变量的作用域是全局的，在执行上下文内的所有代码都能够访问它。

最外层的函数以及最外层变量

```javascript
var globleVariable = 'global';         // 最外层变量

function globalFunc() {                // 最外层函数
  var childVariable = 'global_child';  // 函数内变量

  function childFunc() {                // 内层函数
    console.log(childVariable);
  }
  console.log(globleVariable);
}

console.log(globleVariable);  // global
globalFunc();                 // global

// console.log(childVariable)   // ERROR: childVariable is not defined
// console.log(childFunc)       // ERROR: childFunc is not defined
```

未定义直接赋值的变量

```javascript
function func1(){
  special = 'special_variable';
  var normal = 'normal_variable';
  console.log(special);  // special_variable
}

func1();
console.log(special);    // special_variable

// console.log(normal)      // ERROR: normal is not defined
```

虽然我们可以在全局作用域中声明函数以及变量，使之成为全局变量，但是不建议这么做。因为这可能会导致全局变量和其他的变量名冲突。

```javascript
var globleVariable = "person";
let globleVariable = "animal"; // Error, thing has already been declared
```

另一方面如果你使用 **var** 申明变量，第二个申明的同样的变量将覆盖前面的，这样会使你的代码很难调试。

```javascript
var name = 'name1'
var name = 'name2'
console.log(name);  // name2
```

### 局部作用域

> 和全局作用于相反，局部作用域一般只能在固定代码片段内可以访问到。最常见的就是函数作用域。

#### 函数作用域

定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。
这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。

```javascript
function test(){
  var num = 9;
  console.log("test 中: " + num);
}

console.log("test 外: " + num); // Uncaught ReferenceError: num is not defined
```

如果在函数中定义变量时，如果不添加 **var** 关键字，将会造成变量提升，这个变量将成为一个全局变量。

```javascript
function doSomeThing(){
  thing = 'writting';
  console.log('内部：' + thing);
}
console.log('外部:' + thing)
```

任何一对花括号`｛...｝`中的语句集都属于一个块, 在 **es6** 之前，在块语句中定义的变量将保留在它已经存在的作用域中

```javascript
for(var i = 0; i < 5; i++){
  console.log(i)          // 0 1 2 3 4
}

console.log('{}外部:'+i); // {}外部: 5
```

#### 块级作用域

**ES6** 新增了 **let** 和 **const** 命令，可以用来创建块级作用域变量。
使用 **let** 命令声明的变量只在 **let** 命令所在代码块内有效，变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量

> 其实这个特点带来了许多好处，开发者需要检查代码时候，可以避免在作用域外意外但使用某些变量，而且保证了变量不会被混乱但复用，提升代码的可维护性。就像代码中的例子，一个只在for循环内部使用的变量i不会再去污染整个作用域。

```javascript
console.log(bar);  // Uncaught ReferenceError: bar is not defined

let bar = 2;

for (let i = 0; i < 10;i++){
  console.log(i)
}

console.log(i);    // Uncaught ReferenceError: i is not defined
```

**ES6** 的 **let** 和 **const** 不允许反复声明，与 **var** 不同

```javascript
function test(){
  var name = 'name1';
  var name = 'name2';
  console.log(name);   // name2
}

function test2(){
  const name = 'name1';
  let name = 'name2';  // Uncaught SyntaxError: Identifier 'name' has already been declared
}
```

### 变量提升

> **javascript** 引擎在编译的时，已经把在执行上下文内的变量全部声明，声明后再完成赋值，这个过程就是变量提升。

#### 变量声明提升

```javascript
console.log(a);

var a = 2; // undefined
```

#### 函数声明提升

> 1. **javascript** 引擎会优先进行函数声明，并将函数整个地提升到当前作用域的顶部。
> 2. 当有多个同名变量声明的时候，函数声明会覆盖其他的变量声明。
> 3. 如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明。

函数声明是第一优先级

```javascript
// 函数是一等公民：先声明 function foo 后再声明 var foo
foo();

function foo() {
  console.log('foo');
}

var foo = 2;
console.log(foo);

// foo
// 2
```

函数声明覆盖

```javascript
foo();

function foo() {
  console.log('1');
}

function foo() {
  console.log('2');
}

// 2
```

函数表达式声明

```javascript
foo();

// var foo = function() {} 这种格式 叫做函数表达式。
// 和最开始的例子一样，js 引擎是先声明再赋值
var foo = function() {
  console.log('foo');
}
// Uncaught TypeError: foo is not a function
```

### 作用域链

> 简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链

![ScopeChain](../../assets/image/ScopeChain.jpg)

```javascript
function a() {
    
  function b() {
    console.log(myVar);
    console.log(myVarGlobal);
  }

  var myVar = 2;
  b();
}

var myVarGlobal = 1;

/**
 * 声明顺序
 * 1. 声明 函数 a
 * 2. 声明 子函数 b
 * 3. 声明 变量 myVar
 * 4. 声明 变量 myVarGlobal
 * 
 * 调用 b()
 * console.log(myVar) => 函数b中没有 => 在函数a中找到
 * console.log(myVarGlobal); => 函数b中没有 => 在函数a中没有 => 在全局变量中找到
*/
a(); // 先输出 2 再输出 1

// 函数 b 并没有在外层的全局上下文中声明
b(); // Uncaught ReferenceError: b is not defined
```

## 闭包

> 闭包是在函数里面定义一个函数，该函数可以是匿名函数，该子函数能够读写父函数的局部变量。

### 从一个 🌰 说起

```javascript
function fun(param1, param2) {
  console.log(param2);

  return {
    fun: function(param3){
      return fun(param3, param1);
    }
  }
}

var a = fun(0); // undefined
a.fun(1); // 0
a.fun(2); // 0
a.fun(3); // 0

/**
 * undefined
 * 0
 */
var b = fun(0).fun(1);
b.fun(2); // 1
b.fun(3); // 1

/**
 * undefined
 * 0
 * 1
 * 2
 */
var c = fun(0).fun(1).fun(2).fun(3);
```

#### 图解 **a** 的执行

![1](../../assets/image/a.png)

#### 图解 **b** 的执行

![1](../../assets/image/b.png)

> c 和接下来的执行以此类推

#### 小结

> 根据上面的代码我们不难发现 **function fun** 中的参数在局部作用域中形成了作用域链

- 闭包的本质就是在函数内部定义一个子级作用域函数。
- 闭包在使用的时候不会释放外部的引用，闭包函数内部的值会在当前的局部作用域中常驻。
- 闭包里面的匿名函数，读取变量的顺序，先读取当前作用域中的局部变量，再读取父级作用域的局部变量。


### 闭包的应用

#### 中间件

> Express 中的 🌰 

```javascript
var middleware = function (s) {
  return function (req, res, next) {
    console.log(s);  // hello world
    return next();
  }
}

app.use(middleware('hello world'));
```

#### 私有属性封装

```javascript
var person = function(){    
  var name = "default"; // 变量作用域为函数内部，外部无法访问        
      
  return {    
    getName : function(){    
      return name;    
    },    
    setName : function(newName){    
      name = newName;    
    }    
  }    
}();    
     
console.log(person.name);      // undefined    
console.log(person.getName()); // default
person.setName("name");    
console.log(person.getName()); // name 
```

#### 结果缓存

开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。

```javascript
var CacheService = (function() {
  var cache = {};  

  return {    
    add: function(key) {   
      if (key in cache) return cache[key]; // 直接返回缓存结果 
      cache[key] = doSomethings(); // 执行超级耗时的操作
      return result;          
    },    
  
    clear: function(key){    
      if (key in cache){    
        delete cache[key];     
      }    
    }    
  };    
})();    
     
CacheService.add("input");
CacheService.clear("input");
```

### 闭包与内存泄漏

> **内存泄漏（Memory Leak）**是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

要避免不当使用闭包造成内存泄漏，我们必须了解 javascript 的垃圾回收算法

> **javascript** 的主要垃圾回收算法是通过引用计数
> 
> 1. 假设有 a，b，c 三个对象，当 a 引用 b 的时候，b 的引用计算器增加 1
> 2. b 引用 c 的时候，c 引用计数器增加1，当 a 被释放的时候，b 的引用计数器减少 1，变成 0 的时候被释放，c 计数器变成 0，然后被释放
> 3. 但是当遇到 b 和 c 之间互相引用的时候，无法通过引用计数的方式释放内存。

```javascript
function a() {
  var localVal = 10;
  return function() {
    console.log(localVal);
    return localVal;
  }
}

var funcA = a();
funcA();  // 10
```

根据上面的例子，我们可以发现，当 a 函数结束的时候，想要释放。但是发现它的 localVal 变量被匿名函数引用，a函数无法释放。这种情况，如果使用不当，就会造成内存泄漏。


## 高阶函数

> 高阶函数其实就是一个**接收函数作为参数**或者**将函数作为返回输出**的函数。

### 实现一个简单的高阶函数

```javascript
function add(param1, param2, fun) {
  return fun(param1) + fun(param2);
}

var x = add(-5, 6, Math.abs);
console.log(x);  // 11
```

实际的运算过程

```javascript
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

### Array 内置函数

#### map

> map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

```javascript
const array1 = [1, 4, 9, 16];
const map1 = array1.map(x => x * 2);
console.log(map1); // [2, 8, 18, 32]

function pow(x) {
  return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow);
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]

```

> 语法：array.map(function(currentValue, index, array), thisArg)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|生成新数组元素的函数|
|function.currentValue|是|数组中当前正在处理的元素。|
|function.index|可选|正在处理的元素在数组中的索引。|
|function.array|可选|调用了 map 的数组本身。|
|thisArg|可选|执行 function 时，用于指定 this 指针。|

#### filter

> filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

```javascript
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6);
console.log(result); // expected output: Array ["exuberant", "destruction", "present"]
```

> 语法：arr.filter(function(currentValue, index, array), thisArg)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。|
|function.currentValue|是|数组中当前正在处理的元素。|
|function.index|可选|正在处理的元素在数组中的索引。|
|function.array|可选|调用了 filter 的数组本身。|
|thisArg|可选|执行 function 时，用于指定 this 指针。|

#### reduce

> reduce() 方法对数组中的每个元素执行一个自定义的reducer函数(升序执行)，将其结果汇总为单个返回值。

```javascript
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;
// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer)); // expected output: 10
// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5)); // expected output: 15
```

```javascript
var maxCallback = ( acc, cur ) => Math.max( acc.x, cur.x );
var maxCallback2 = ( max, cur ) => Math.max( max, cur );

// reduce() 没有初始值
[ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback ); // NaN
[ { x: 2 }, { x: 22 }            ].reduce( maxCallback ); // 22
[ { x: 2 }                       ].reduce( maxCallback ); // { x: 2 }
[                                ].reduce( maxCallback ); // TypeError

// map/reduce; 这是更好的方案，即使传入空数组或更大数组也可正常执行
[ { x: 22 }, { x: 42 } ].map( el => el.x )
                        .reduce( maxCallback2, -Infinity );
```

> 语法：arr.reduce(function(accumulator, currentValue, index, array), initialValue)

|参数|必须|介绍|
|:-:|:-:|:-:|
|function|是|执行数组中每个值的函数|
|function.accumulator|是|累加器累加回调的返回值，它是上一次调用回调时返回的累积值，或initialValue|
|function.currentValue|是|数组中正在处理的元素。|
|function.currentIndex|可选| 可选，数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。|
|function.array|可选|调用了 reduce 的数组本身。|
|initialValue|可选|可选，用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错|

**一些实用的 demo**

> 按属性分类

```javascript
var people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 }
];

function groupBy(objectArray, property) {
  return objectArray.reduce(function (acc, obj) {
    var key = obj[property];
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(obj);
    return acc;
  }, {});
}

var groupedPeople = groupBy(people, 'age');
// groupedPeople is:
// {
//   20: [
//     { name: 'Max', age: 20 },
//     { name: 'Jane', age: 20 }
//   ],
//   21: [{ name: 'Alice', age: 21 }]
// }
```

> 将二维数组转化为一维

```javascript
var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
  function(a, b) {
    return a.concat(b);
  },
  []
);
// flattened is [0, 1, 2, 3, 4, 5]
```


#### sort

> sort() 方法用原地算法对数组的元素进行排序，并返回数组，该排序方法会在原数组上直接进行排序，并不会生成一个排好序的新数组。默认排序顺序是根据 **字符串Unicode码点**。**由于它取决于具体实现，因此无法保证排序的时间和空间复杂性**。

```javascript
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();
console.log(months);
// expected output: Array ["Dec", "Feb", "Jan", "March"]

const array1 = [1, 30, 4, 21, 100000];
array1.sort();
console.log(array1);
// expected output: Array [1, 100000, 21, 30, 4]
```

> 语法 arr.sort([compareFunction])

|参数|必须|介绍|
|:-:|:-:|:-:|
|compareFunction|可选|指定按某种顺序进行排列的函数|
|function.firstEl|是|第一个用于比较的元素。|
|function.secondEl|是|第二个用于比较的元素。|

> 使用默认的 sort 函数时，底层只有两种排序： **InsertionSort** 和 **QuickSort**，数量小于等于22的数组使用 InsertionSort，比22大的数组则使用 QuickSort
> 
> [点我看源码](https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js)

```
// In-place QuickSort algorithm.
// For short (length <= 22) arrays, insertion sort is used for efficiency.
```

### 常见问题

#### 注意高阶参数的可选参数

> 以 map 为例

```javascript
["1", "2", "3"].map(parseInt); // 不输出 [1,2,3]，而是输出 [1,NaN,NaN]

parseInt("1",0); // 上面说过第二个参数为进制，所以"1"，radix为0上面提到过，会忽略，根据string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数1。
parseInt("2",1); // 此时将2转为1进制数，由于超过进制数1，所以返回NaN。
parseInt("3",2); // 此时将3转为2进制数，由于超过进制数1，所以返回NaN。
```

导致这个问题的原因是 **parseInt** 有两个参数，**string** 和 **radix**(进制)。

通常我们使用时，会忽略第二个参数 **radix**，因为当 **radix** 为 0 或者不传的时候，**parseInt()** 会根据 **string** 来自动处理:

- 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
- 如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。
- 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。


#### 注意高阶参数的返回值

> 以 map 为例

```javascript
// 需要 return 值，否则会出现所有项置为 为 undefined

const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item => {});

console.log(arr2);
// [ undefined, undefined, undefined, undefined ]
console.log(arr1);
// [1, 2, 3, 4]
```