# JavaScript 中的闭包

> 闭包是在函数里面定义一个函数，该函数可以是匿名函数，该子函数能够读写父函数的局部变量。

## 举一个 🌰

```javascript
function fun(param1, param2) {
  console.log(param2);

  return {
    fun: function(param3){
      return fun(param3, param1);
    }
  }
}

var a = fun(0); // undefined
a.fun(1); // 0
a.fun(2); // 0
a.fun(3); // 0

/**
 * undefined
 * 0
 */
var b = fun(0).fun(1);
b.fun(2); // 1
b.fun(3); // 1

/**
 * undefined
 * 0
 * 1
 * 2
 */
var c = fun(0).fun(1).fun(2).fun(3);
```

### 图解 **a** 的执行

![1](../../assets/image/a.png)

### 图解 **b** 的执行

![1](../../assets/image/b.png)

> c 和接下来的执行以此类推

## 闭包与内存泄漏

> javascript的主要通过计数器方式回收内存，假设有a，b，c三个对象，当a引用b的时候，那么b的引用计算器增加1(通俗的说用到那个对象哪个对象引用计算器增加1)，同时b引用c的时候，c引用计数器增加1，当a被释放的时候，b的引用计数器减少1，变成0的时候这个对象被释放，c计数器变成0，被释放,但是当遇到b和c之间互相引用的时候，无法通过计数器方式释放内存。


```javascript
function a() {
  var localVal = 10;
  return localVal;
}

a(); // 30


function a() {
  var localVal = 10;
  return function() {
    console.log(localVal);
    return localVal;
  }
}

var funcA = a();
funcA();  // 10
```

当a函数结束的时候，想要释放，发现它的localVal变量被匿名函数引用，a函数无法释放，导致内存泄漏。但是也有好处，闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。

说明:闭包不代表一定会带来内存泄漏，良好的使用闭包是不会造成内存泄漏的。

## 闭包的应用

### 中间件

> Express 中的 🌰 

```javascript
var middleware = function (s) {
  return function (req, res, next) {
    console.log(s);  // hello world
    return next();
  }
}

app.use(middleware('hello world'));
```

### 私有属性封装

```javascript
var person = function(){    
  var name = "default"; // 变量作用域为函数内部，外部无法访问        
      
  return {    
    getName : function(){    
      return name;    
    },    
    setName : function(newName){    
      name = newName;    
    }    
  }    
}();    
     
console.log(person.name);      // undefined    
console.log(person.getName()); // default
person.setName("name");    
console.log(person.getName()); // name 
```

### 结果缓存

开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。

```javascript
var CacheService = (function() {
  var count = 0;
  var cache = {};  

  return {    
    add: function(key) {   
      // 直接返回缓存结果 
      if (key in cache) return cache[key];

      // 限制缓存大小，移除第一个元素
      if (count >= 100) delete cache[Object.keys(cache)[0]];

      // 执行超级耗时的操作
      cache[key] = doSomethings(); 

      count++;

      return result;          
    },    
  
    clear: function(key){    
      if (key in cache){    
        delete cache[key];     
      }    
    }    
  };    
})();    
     
CacheService.add("input");
CacheService.clear("input");
```

## 总结

- 闭包其实是在函数内部定义一个函数。
- 闭包在使用的时候不会释放外部的引用，闭包函数内部的值会得到保留。
- 闭包里面的匿名函数，读取变量的顺序，先读取本地变量，再读取父函数的局部变量。
- 对于闭包外部无法引用它内部的变量，因此在函数内部创建的变量执行完后会立刻释放资源，不污染全局对象。
- 闭包使用的时候要考虑到内存泄漏，因为不释放外部引用，但是合理的使用闭包是内存使用不是内存泄漏。
- 闭包，并不是什么坏东西，不要每次提到闭包都与内存泄漏挂钩，正常使用闭包，是使用内存，不是内存泄漏，请充分利用好闭包的特性。