# JavaScript 中的高阶函数

> **JavaScript** 的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

实现一个简单的高阶函数

```javascript
function add(param1, param2, fun) {
  return fun(param1) + fun(param2);
}

var x = add(-5, 6, Math.abs);
console.log(x);  // 11
```

实际的运算过程

```javascript
x = -5;
y = 6;
f = Math.abs;
f(x) + f(y) ==> Math.abs(-5) + Math.abs(6) ==> 11;
return 11;
```

## Array中的常见方法

### map

> - 语法: **array.map(function(currentValue, index, arr), thisValue)**
> - function(currentValue, index, arr) 必须。函数，数组中的每个元素都会执行这个函数
>   - currentValue	必须。当前元素的值
>   - index	可选。当前元素的索引值
>   - arr	可选。当前元素属于的数组对象
> - thisValue	可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。
>   如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。

```javascript
function pow(x) {
  return x * x;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow);
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

#### 结合一些例子来看 map callback 函数的隐患

> 隐藏的 **index**

```javascript
["1", "2", "3"].map(parseInt);
// 不输出 [1,2,3]，而是输出 [1,NaN,NaN]

parseInt("1",0);//上面说过第二个参数为进制，所以"1"，radix为0上面提到过，会忽略，根据string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数1。
parseInt("2",1);//此时将2转为1进制数，由于超过进制数1，所以返回NaN。
parseInt("3",2);//此时将3转为2进制数，由于超过进制数1，所以返回NaN。
```

导致这个问题的原因是 **parseInt** 有两个参数，string和radix(进制)。

注意第二个参数进制当为0或者没有参数的时候，parseInt()会根据string来判断数字的基数。当忽略参数 radix。

- 如果 string 以 "0x" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。
- 如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。
- 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。

> 需要有 **return** 值，否则会出现所有项置为 为 **undefind**

```javascript
const arr1 = [1, 2, 3, 4];
const arr2 = arr1.map(item => {});

console.log(arr2);
// [ undefined, undefined, undefined, undefined ]
console.log(arr1);
// [1, 2, 3, 4]
```

### filter

### reduce

### sort
