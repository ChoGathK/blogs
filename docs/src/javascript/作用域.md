# JavaScript 中的作用域

> 作用域（scope），是一个程序设计概念。通常来说，一段程序代码中所用到的变量并不总是有效或者可用的，而限定这个变量的可用性的代码范围就是这个名字的作用域

## 全局作用域

> 函数之外声明的变量，或未定义直接赋值的变量（由于变量提升变成了全局变量），都会成为全局变量。全局变量的作用域是全局的，在执行上下文内的所有代码都能够访问它。

最外层的函数以及最外层变量

```javascript
var globleVariable = 'global';         // 最外层变量

function globalFunc() {                // 最外层函数
  var childVariable = 'global_child';  // 函数内变量

  function childFunc() {                // 内层函数
    console.log(childVariable);
  }
  console.log(globleVariable);
}

console.log(globleVariable);  // global
globalFunc();                 // global

// console.log(childVariable)   // ERROR: childVariable is not defined
// console.log(childFunc)       // ERROR: childFunc is not defined
```

未定义直接赋值的变量

```javascript
function func1(){
  special = 'special_variable';
  var normal = 'normal_variable';
  console.log(special);  // special_variable
}

func1();
console.log(special);    // special_variable

// console.log(normal)      // ERROR: normal is not defined
```

虽然我们可以在全局作用域中声明函数以及变量，使之成为全局变量，但是不建议这么做。因为这可能会导致全局变量和其他的变量名冲突。

```javascript
var globleVariable = "person";
let globleVariable = "animal"; // Error, thing has already been declared
```

另一方面如果你使用 **var** 申明变量，第二个申明的同样的变量将覆盖前面的，这样会使你的代码很难调试。

```javascript
var name = 'name1'
var name = 'name2'
console.log(name);  // name2
```

## 局部作用域

> 和全局作用于相反，局部作用域一般只能在固定代码片段内可以访问到。最常见的就是函数作用域。

### 函数作用域

定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。
这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。

```javascript
function test(){
  var num = 9;
  console.log("test 中: " + num);
}

console.log("test 外: " + num); // Uncaught ReferenceError: num is not defined
```

如果在函数中定义变量时，如果不添加 **var** 关键字，将会造成变量提升，这个变量将成为一个全局变量。

```javascript
function doSomeThing(){
  thing = 'writting';
  console.log('内部：' + thing);
}
console.log('外部:' + thing)
```

任何一对花括号`｛...｝`中的语句集都属于一个块, 在 **es6** 之前，在块语句中定义的变量将保留在它已经存在的作用域中

```javascript
for(var i = 0; i < 5; i++){
  console.log(i)          // 0 1 2 3 4
}

console.log('{}外部:'+i); // {}外部: 5
```

### 块级作用域

**ES6** 新增了 **let** 和 **const** 命令，可以用来创建块级作用域变量。
使用 **let** 命令声明的变量只在 **let** 命令所在代码块内有效，变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量

> 其实这个特点带来了许多好处，开发者需要检查代码时候，可以避免在作用域外意外但使用某些变量，而且保证了变量不会被混乱但复用，提升代码的可维护性。就像代码中的例子，一个只在for循环内部使用的变量i不会再去污染整个作用域。

```javascript
console.log(bar);  // Uncaught ReferenceError: bar is not defined

let bar = 2;

for (let i = 0; i < 10;i++){
  console.log(i)
}

console.log(i);    // Uncaught ReferenceError: i is not defined
```

**ES6** 的 **let** 和 **const** 不允许反复声明，与 **var** 不同

```javascript
function test(){
  var name = 'name1';
  var name = 'name2';
  console.log(name);   // name2
}

function test2(){
  const name = 'name1';
  let name = 'name2';  // Uncaught SyntaxError: Identifier 'name' has already been declared
}
```

## 变量提升

> **javascript** 引擎在编译的时，已经把在执行上下文内的变量全部声明，声明后再完成赋值，这个过程就是变量提升。

### 变量声明提升

```javascript
console.log(a);

var a = 2; // undefined
```

### 函数声明提升

> 1. **javascript** 引擎会优先进行函数声明，并将函数整个地提升到当前作用域的顶部。
> 2. 当有多个同名变量声明的时候，函数声明会覆盖其他的变量声明。
> 3. 如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明。

函数声明是第一优先级

```javascript
// 函数是一等公民：先声明 function foo 后再声明 var foo
foo();

function foo() {
  console.log('foo');
}

var foo = 2;
console.log(foo);

// foo
// 2
```

函数声明覆盖

```javascript
foo();

function foo() {
  console.log('1');
}

function foo() {
  console.log('2');
}

// 2
```

函数表达式声明

```javascript
foo();

// var foo = function() {} 这种格式 叫做函数表达式。
// 和最开始的例子一样，js 引擎是先声明再赋值
var foo = function() {
  console.log('foo');
}
// Uncaught TypeError: foo is not a function
```

## 作用域链

> 简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链

![ScopeChain](../../assets/image/ScopeChain.jpg)

```javascript
function a() {
    
  function b() {
    console.log(myVar);
    console.log(myVarGlobal);
  }

  var myVar = 2;
  b();
}

var myVarGlobal = 1;

/**
 * 声明顺序
 * 1. 声明 函数 a
 * 2. 声明 子函数 b
 * 3. 声明 变量 myVar
 * 4. 声明 变量 myVarGlobal
 * 
 * 调用 b()
 * console.log(myVar) => 函数b中没有 => 在函数a中找到
 * console.log(myVarGlobal); => 函数b中没有 => 在函数a中没有 => 在全局变量中找到
*/
a(); // 先输出 2 再输出 1

// 函数 b 并没有在外层的全局上下文中声明
b(); // Uncaught ReferenceError: b is not defined
```
