# JavaScript 中的作用域

- 定义
- 作用域（scope），是一个程序设计概念
- 通常来说，一段程序代码中所用到的变量并不总是有效 / 可用的，而限定这个变量的可用性的代码范围就是这个名字的作用域
- 类型
- 全局作用域
- 拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域
- 最外层的函数以及最外层变量:

- 未定义直接赋值的变量(由于变量提升使之成为全局变量)

- 虽然我们可以在全局作用域中声明函数以及变量, 使之成为全局变量, 但是不建议这么做,因为这可能会和其他的变量名冲突,一方面如果我们再使用const或者let声明变量, 当命名发生冲突时会报错。

- 另一方面如果你使用var申明变量，第二个申明的同样的变量将覆盖前面的,这样会使你的代码很难调试。

- 局部作用域
- 和全局作用于相反，局部作用域一般只能在固定代码片段内可以访问到。最常见的就是函数作用域。
- 函数作用域
- 定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。

- 如果在函数中定义变量时,如果不添加var关键字,造成变量提升，这个变量成为一个全局变量。

- 任何一对花括号｛...｝中的语句集都属于一个块, 在es6之前，在块语句中定义的变量将保留在它已经存在的作用域中：

- 变量提升
- 变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的“hoisting”，也就是变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。 看一段代码

- 在这里申明提升了，定义的内容并不会提升，提升实际运行的代码如下

- console在输出的时候，tmp变量仅仅申明了但未定义。所以输出undefined。虽然能够输出，但是并不推荐这种写法推荐的做法是在申明变量的时候，将所用的变量都写在作用域（全局作用域或函数作用域）的最顶上，这样代码看起来就会更清晰，更容易看出来哪个变量是来自函数作用域的，哪个又是来自作用域链
- 重复声明
- 变量和函数同时出现的提升
- 块级作用域
- 作用域链