# JavaScript 中的作用域

## 定义

> 作用域（scope），是一个程序设计概念，通常来说，一段程序代码中所用到的变量并不总是有效 / 可用的，而限定这个变量的可用性的代码范围就是这个名字的作用域

## 类型

### 全局作用域

> 全局变量的默认作用域是整个程序，也就是所有需要执行的代码
  
- 最外层的函数以及最外层变量

```javascript
var globleVariable= 'global';  // 最外层变量
function globalFunc(){         // 最外层函数
  var childVariable = 'global_child';  //函数内变量
  function childFunc(){        // 内层函数
    console.log(childVariable);
  }
  console.log(globleVariable)
}
console.log(globleVariable);  // global
globalFunc();                 // global
// console.log(childVariable)   // ERROR: childVariable is not defined
// console.log(childFunc)       // ERROR: childFunc is not defined
```

- 未定义直接赋值的变量(由于变量提升使之成为全局变量)

```javascript
function func1(){
  special = 'special_variable';
  var normal = 'normal_variable';
}
func1();
console.log(special);    // special_variable
console.log(normal)     // ERROR: normal is not defined
```

> 缺陷和隐患

- 虽然我们可以在全局作用域中声明函数以及变量, 使之成为全局变量, 但是不建议这么做,因为这可能会和其他的变量名冲突,一方面如果我们再使用const或者let声明变量, 当命名发生冲突时会报错。

```javascript
// 变量冲突
var globleVariable = "person";
let globleVariable = "animal"; // Error, thing has already been declared
```

- 另一方面如果你使用var申明变量，第二个申明的同样的变量将覆盖前面的,这样会使你的代码很难调试。

```javascript
var name = 'name1'
var name = 'name2'
console.log(name);  // name2
```

### 局部作用域

> 和全局作用于相反，局部作用域一般只能在固定代码片段内可以访问到。最常见的就是函数作用域。

#### 函数作用域

- 定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。

```javascript
//全局作用域
function test(){
  var num = 9;
  // 内部可以访问
  console.log("test中："+num);
}
//test外部不能访问
console.log("test外部:"+num);
```

- 如果在函数中定义变量时，如果不添加var关键字，造成变量提升，这个变量将成为一个全局变量。

```javascript
function doSomeThing(){
    // 在工作中一定避免这样写
    thing = 'writting';
    console.log('内部：'+thing);
}
console.log('外部:'+thing)
```

- 任何一对花括号｛...｝中的语句集都属于一个块, 在es6之前，在块语句中定义的变量将保留在它已经存在的作用域中

```javascript
var name = '程序员成长指北';
for(var i=0; i<5; i++){
    console.log(i)
}
console.log('{}外部:'+i);
// 0 1 2 3 4  {}外部:5
```

#### 块级作用域

> ES6新增了let和const命令，可以用来创建块级作用域变量，使用let命令声明的变量只在let命令所在代码块内有效。

- 变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量

  > 其实这个特点带来了许多好处，开发者需要检查代码时候，可以避免在作用域外意外但使用某些变量，而且保证了变量不会被混乱但复用，提升代码的可维护性。就像代码中的例子，一个只在for循环内部使用的变量i不会再去污染整个作用域。

```javascript
console.log(bar);//抛出`ReferenceErro`异常: 某变量 `is not defined`
let bar=2;
for (let i =0; i<10;i++){
    console.log(i)
}
console.log(i);//抛出`ReferenceErro`异常: 某变量 `is not defined`
```

- ES6的let和const不允许反复声明，与var不同

```javascript
// var
function test(){
    var name = 'name1';
    var name = 'name2';
    console.log(name); // name2
}

// let || const
function test2(){
    var name ='name1';
    let name= 'name2'; 
    // Uncaught SyntaxError: Identifier 'count' has already been declared
}
```

### 变量提升

- 变量申明是在任意代码执行前处理的，在代码区中任意地方申明变量和在最开始（最上面）的地方申明是一样的。也就是说，看起来一个变量可以在申明之前被使用！这种行为就是所谓的 **"hoisting"** —— 变量提升，看起来就像变量的申明被自动移动到了函数或全局代码的最顶上。

```javascript
var tmp = new Date();
function f() {
    console.log(tmp);
    if(false) {
        var tmp='hello';
    }
}
```

- 在这里申明提升了，定义的内容并不会提升，提升实际运行的代码如下

  > console在输出的时候，tmp变量仅仅申明了但未定义。所以输出undefined。虽然能够输出，但是并不推荐这种写法推荐的做法是在申明变量的时候，将所用的变量都写在作用域（全局作用域或函数作用域）的最顶上，这样代码看起来就会更清晰，更容易看出来哪个变量是来自函数作用域的，哪个又是来自作用域链

```javascript
var tmp = new Date();
function f() {
    var tmp;
    console.log(tmp);
    if(false) {
        tmp='hello';
    }
}
f();
```

### 重复声明

```javascript
// var
var name = 'name';
console.log(name); // name
if(true){
    var name = 'name2';
    console.log(name); // name2
}
console.log(name); // name2
```

### 变量和函数同时出现的提升

> 如果有函数和变量同时声明了，会出现什么情况呢？看下面但代码

```javascript
console.log(foo); // 输出结果是function foo(){},也就是函数内容
var foo ='i am foo';
function foo(){}
```

> 如果是另外一种形式呢？

```javascript
console.log(foo); // 输出结果是undefined
var foo ='i am foo';
var foo=function (){}
```

对两种结果进行分析说明：

- 第一种：函数申明。就是上面第一种，**function foo(){}** 这种形式
- 另一种：函数表达式。就是上面第二种，**var foo=function(){}** 这种形式
- 第二种形式其实就是var变量的声明定义，因此上面的第二种输出结果为 **undefined** 应该就能理解了。
- 而第一种函数申明的形式，在提升的时候，会被整个提升上去，包括函数定义的部分！因此第一种形式跟下面的这种方式是等价的！

```javascript
var foo=function (){}
console.log(foo);
var foo ='i am foo';
```

原因是：

- 函数声明被提升到最顶上；
- 申明只进行一次，因此后面var foo='i am foo'的申明会被忽略。
- 函数申明的优先级优于变量申明，且函数声明会连带定义一起被提升（这里与变量不同）

### 作用域链
...