# JavaScript 中的数据类型

## 弱类型语言

> 编程语言的类型强弱是站在变量类型处理的角度进行分类的。

- **强类型**
  - 不允许隐式变量类型转换。
  - 当你定义一个变量是某个类型，如果不经过代码显式转换/强制转化过，它就永远都是这个类型，如果把它当做其他类型来用，就会报错。

```typescript
const str: string = 'str';
const sum: number = str + 1; // ERROR: 不能将类型“string”分配给类型“number”
```

- **弱类型**
  - 允许隐式类型转换。
  - 你想把这个变量当做什么类型来用，就当做什么类型来用，语言的解析器会自动（隐式）转换。

```javascript
const str = 'str';
const sum = str + 1; // str1
```

> 这里涉及到一个关键概念，即：隐式转换

- **隐式转换**指源码中没有明显的类型转换代码，也就是说，一个变量可以直接赋值字符串，也可以直接赋值数值，还可以直接让字符串类型的变量和数值类型的变量相加。
  
## 动态类型语言

> 编程语言的类型静态与动态是站在变量类型检查时的角度进行分类的。

- **动态类型**：在运行期进行类型检查，也就是在编写代码的时候可以不指定变量的数据类型。
- **静态类型**：在编译期进行检查，也就是说变量在使用前要声明变量的数据类型。

## 数据类型

### 对象/引用类型

> 对象类型也叫引用类型，其中 **array** 和 **function** 是对象的子类型。对象在逻辑上是属性的无序集合，是存放各种值的容器。

### 基础类型

> **string**、**number**、**boolean**、**null**、**undefined** 为原始类型，表示不能再细分下去的基本类型。
> 
> **null** 和 undefined 通常被认为是特殊值，这两种类型的值唯一，就是其本身
> 
> **symbol** 是ES6中新增的数据类型，symbol 表示独一无二的值，通过 **Symbol** 函数调用生成，由于生成的 **symbol** 值为原始类型，所以 **Symbol** 函数不能使用 **new** 调用。

- **String**（字符串）
- **Boolean**（布尔值）
- **Number**（数字）
- **Symbol**（符号）
- **null**（空值）
- **undefined**（未定义）

## 隐式转换原理

### 转换对象/引用类型

#### 原始值转换算法

> **ToPrimitive** 接受一个值，和一个可选的期望类型作参数。
>
> **ToPrimitive** 对原始类型不发生转换处理，只针对引用类型，其目的是将引用类型转换为原始类型。

```javascript
/**
* @obj 需要转换的对象
* @type 期望转换为的原始数据类型，可选
*/
ToPrimitive(obj, type)
```

> 期望类型为 **string**

- 先调用 obj 的 **toString** 方法，如果为原始值，则 **return**，否则进行第2步
- 调用 obj 的 **valueOf** 方法，如果为原始值，则 **return**，否则进行第3步
- 抛出 TypeError 异常

> 期望类型为 **number**

- 先调用 obj 的 **valueOf** 方法，如果为原始值，则 **return**，否则进行第2步
- 调用 obj 的 **toString** 方法，如果为原始值，则 **return**，否则第3步
- 抛出 TypeError 异常

> 不存在期望类型

- 该对象为 **Date**，则 **type** 被设置为 **string**
- 否则，**type** 被设置为 **number**

#### 返回对象的字符串 toString

> 每个对象都有一个 toString 方法，当对象被表示为文本值时或者当以期望字符串的方式引用对象时，该方法被自动调用。

#### 返回对象的原始值 valueOf

> 用来把对象转换成原始类型的值（数值、字符串和布尔值），valueOf 方法一般都会被 JavaScript 自动调用。

内置对象的 **valueOf** 实现：

- String => 返回字符串值
- Number => 返回数字值
- Date => 返回一个数字，即时间值,字符串中内容是依赖于具体实现的
- Boolean => 返回Boolean的this值
- Object => 返回this

```javascript
var str = new String('123');
console.log(str.valueOf());//123

var num = new Number(123);
console.log(num.valueOf());//123

var date = new Date();
console.log(date.valueOf()); //1526990889729

var bool = new Boolean('123');
console.log(bool.valueOf());//true

var obj = new Object({valueOf:()=>{
    return 1
}})
console.log(obj.valueOf());//1
```

### 转换基础类型

#### Number

- null 转换为 0
- undefined 转换为 NaN
- true 转换为 1，false 转换为 0
- 字符串转换时遵循数字常量规则，转换失败返回 NaN

#### String

- null 转换为 'null'
- undefined 转换为 undefined
- true 转换为 'true'，false 转换为 'false'
- 数字转换遵循通用规则，极大极小的数字使用指数形式

```javascript
String(null)                 // 'null'
String(undefined)            // 'undefined'
String(true)                 // 'true'
String(1)                    // '1'
String(-1)                   // '-1'
String(0)                    // '0'
String(-0)                   // '0'
String(Math.pow(1000,10))    // '1e+30'
String(Infinity)             // 'Infinity'
String(-Infinity)            // '-Infinity'
String({})                   // '[object Object]'
String([1,[2,3]])            // '1,2,3'
String(['2',1])          //2,1
```

#### Boolean

- 除了下述 6 个值转换结果为 false，其他全部为 true
- undefined
- null
- -0 
- 0
- +0
- NaN
- ''（空字符串）

```javascript
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false

Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

### 转换场景

#### String

- 字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。
- 与基础数据类型交互

```javascript
'2' + 1 // '21'
'2' + true // "2true"
'2' + false // "2false"
'2' + undefined // "2undefined"
'2' + null // "2null"
```
- 与对象（引用）数据类型交互
  
```javascript
//toString的对象
var obj2 = {
  toString:function(){
    return 'a'
  }
}
console.log('2'+obj2)
//输出结果2a

//常规对象
var obj1 = {
  a:1,
  b:2
}
console.log('2'+obj1)；
//输出结果 2[object Object]

//几种特殊对象
'2' + {} // "2[object Object]"
'2' + [] // "2"
'2' + function (){} // "2function (){}"
'2' + ['3',1] // 23,1
```

#### Number

- 有加法运算符，但是无String类型的时候，都会优先转换为Number类型

```javascript
true + 0 // 1
true + true // 2
true + false //1
```
- 除了加法运算符，其他运算符都会把运算自动转成数值

```javascript
// null转为数值时为0，而undefined转为数值时为NaN。
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN

//一元运算符（注意点）
+'abc' // NaN
-'abc' // NaN
+true // 1
-false // 0
```

#### Boolean

- 布尔比较，if(obj) , while(obj) 等判断时或者 三元运算符只能够包含布尔值
- 条件部分的每个值都相当于false，使用否定运算符后，就变成了true

```javascript
if ( !undefined
  && !null
  && !0
  && !NaN
  && !''
) {
  console.log('true');
} // true

//下面两种情况也会转成布尔类型
expression ? true : false
!! expression
```

#### 等于运算符（==）
== 抽象相等比较与 + 运算符不同，不再是String优先，而是Number优先

- 如果存在对象，ToPrimitive type为number进行转换，再进行后面比较

```javascript
var obj1 = {
    valueOf:function(){
        return '1'
    }
}
1 == obj1  //true
//obj1转为原始值，调用obj1.valueOf()
//返回原始值'1'
//'1'toNumber得到 1 然后比较 1 == 1
[] == ![] //true
//[]作为对象ToPrimitive得到 ''  
//![]作为boolean转换得到0 
//'' == 0 
//转换为 0==0 //true
```

- 存在boolean，按照ToNumber将boolean转换为1或者0，再进行后面比较

```javascript
//boolean 先转成number，按照上面的规则得到1  
//3 == 1 false
//0 == 0 true
3 == true // false
'0' == false //true
```

- 如果x为string，y为number，x转成number进行比较

```javascript
//'0' toNumber()得到 0  
//0 == 0 true
'0' == 0 //true
```

## 类型判断

### typeof

```javascript
typeof 'seymoe'    // 'string'
typeof true        // 'boolean'
typeof 10          // 'number'
typeof Symbol()    // 'symbol'
typeof null        // 'object' 无法判定是否为 null
typeof undefined   // 'undefined'

typeof {}           // 'object'
typeof []           // 'object'
typeof(() => {})    // 'function'
```

- null 的判定有误差，得到的结果 如果使用 typeof，null得到的结果是object
- 操作符对对象类型及其子类型，例如函数（可调用对象）、数组（有序索引对象）等进行判定，则除了函数都会得到 object 的结果。
- 综上可以看出typeOf对于在对象的子类型和null情况下判断类型还有一些不足。

### instanceof

```javascript
[] instanceof Array            // true
({}) instanceof Object         // true
(()=>{}) instanceof Function   // true
```

- 通过 instanceof 操作符也可以对对象类型进行判定，其原理就是测试构造函数的 prototype 是否出现在被检测对象的原型链上。
- 但是 instanceof 也不是万能的。

```javascript
let arr = []
let obj = {}
arr instanceof Array    // true
arr instanceof Object   // true
obj instanceof Object   // true
```

- 在这个例子中，arr 数组相当于 new Array 出的一个实例，所以 arr.__proto__ === Array.prototype，又因为 Array 属于 Object 子类型，即 Array.prototype.__proto__ === Object.prototype，因此 Object 构造函数在 arr 的原型链上。所以 instanceof 仍然无法优雅的判断一个值到底属于数组还是普通对象。
- 还有一点需要说明下，有些开发者会说 Object.prototype.__proto__ === null，岂不是说 arr instanceof null 也应该为 true，这个语句其实会报错提示右侧参数应该为对象，这也印证 typeof null 的结果为 object 真的只是javascript中的一个 bug 。

### Object.prototype.toString

```javascript
Object.prototype.toString.call({})              // '[object Object]'
Object.prototype.toString.call([])              // '[object Array]'
Object.prototype.toString.call(() => {})        // '[object Function]'
Object.prototype.toString.call('seymoe')        // '[object String]'
Object.prototype.toString.call(1)               // '[object Number]'
Object.prototype.toString.call(true)            // '[object Boolean]'
Object.prototype.toString.call(Symbol())        // '[object Symbol]'
Object.prototype.toString.call(null)            // '[object Null]'
Object.prototype.toString.call(undefined)       // '[object Undefined]'

Object.prototype.toString.call(new Date())      // '[object Date]'
Object.prototype.toString.call(Math)            // '[object Math]'
Object.prototype.toString.call(new Set())       // '[object Set]'
Object.prototype.toString.call(new WeakSet())   // '[object WeakSet]'
Object.prototype.toString.call(new Map())       // '[object Map]'
Object.prototype.toString.call(new WeakMap())   // '[object WeakMap]'
```

- 该方法在传入任何类型的值都能返回对应准确的对象类型
- 该方法本质就是依托Object.prototype.toString 方法得到对象内部属性 [[Class]]
- 传入原始类型却能够判定出结果是因为对值进行了包装
- null 和 undefined 能够输出结果是内部实现有做处理

## NAN

- NaN 是一个全局对象的属性，是一种特殊的Number类型。
  
- 什么时候返回NaN 
  - 无穷大除以无穷大
  - 给任意负数做开方运算
  - 算数运算符与不是数字或无法转换为数字的操作数一起使用
  - 字符串解析成数字

```javascript
Infinity / Infinity;   // 无穷大除以无穷大
Math.sqrt(-1);         // 给任意负数做开方运算
'a' - 1;               // 算数运算符与不是数字或无法转换为数字的操作数一起使用
'a' * 1;
'a' / 1;
parseInt('a');         // 字符串解析成数字
parseFloat('a');

Number('a');   //NaN
'abc' - 1   // NaN
undefined + 1 // NaN
//一元运算符（注意点）
+'abc' // NaN
-'abc' // NaN
```