# JavaScript 中的基本概念

## 语言特性

### 弱类型语言

> 按变量类型处理的角度进行分类。

- 强类型语言
  - 不允许隐式变量类型转换。
  - 当你定义一个变量是某个类型，如果不经过代码显式转换/强制转化过，它就永远都是这个类型，如果把它当做其他类型来用，就会报错。

```typescript
const str: string = 'str';
const sum: number = str + 1; // ERROR: 不能将类型“string”分配给类型“number”
```

- 弱类型
  - 允许隐式类型转换。
  - 你想把这个变量当做什么类型来用，就当做什么类型来用，语言的解析器会自动（隐式）转换。

```javascript
const str = 'str';
const sum = str + 1; // str1
```

### 动态类型语言

> 按变量类型检查运行时进行分类。

- 动态类型：在运行期进行类型检查，也就是在编写代码的时候可以不指定变量的数据类型。
- 静态类型：在编译期进行检查，也就是说变量在使用前要声明变量的数据类型。

### 解释型语言（脚本语言）

> 按运行时是否需要解释器进行分类

- 编译型
  - 编译生成的可执行程序可以以脱离开发环境，在特定的平台上独立运行。
  - 因为编译型语言是一次性的编译成机器码，所以可以脱离开发环境独立运行，而且通常运行效率较高；
  - 但因为编译性语言的程序被编译成特定平台上的机器码，因此编译生成的可执行程序通常无法移植到其他平台上运行；如果需要移植，则必须将源代码复制到特定的平台上，针对特定的平台进行修改，至少也需要采用特定平台上的编译器重新编译。
  - 常用的编译型语言如：C、C++、Objective-C、Pasca。

- 解释型
  - 每次执行解释型语言的程序都需要进行一次编译，因此解释型语言的程序运行效率通常较低，而且它不能脱离解释器独立运行。
  - 解释性语言可以方便的实现源程序的移植，但这是以牺牲程序执行效率为代价的。

### 基于原型，万物皆对象

在 JavaScript 中的所有事物都可以通过对象来描述（[**⚠️ null 除外**](#关于-null-与-undefined)），而对象的原型是创造属性和方法的一种实现方法

### 跨平台

根据不同的运行时环境，可以应用在服务器端、浏览器端、客户端。

## 语法

### 声明、赋值和运算

**变量标识符（也可以叫做变量名）**

> 在 JavaScript 中，需要按唯一的名称，标识一个变量。 标识符可以是短名称（比如 x 和 y），或者更具描述性的名称（age、sum）。

- 名称可包含字母、数字、下划线和美元符号
- 名称必须以字母开头
- 名称也可以 $ 和 _ 开头（但是通常我们不会这么做）
- 名称对大小写敏感（y 和 Y 是不同的变量）
- 保留字（比如 JavaScript 的关键词）无法用作变量名称

[JavaScript 保留关键字速查](https://www.runoob.com/js/js-reserved.html)

**赋值运算符**

在 JavaScript 中，等号 `=` 是赋值运算符，而不是“等于”运算符。

**声明赋值**

通过 `var` 关键词声明变量标识符

```javascript
var carName; // 声明后如果没有赋值，那么变量值为 undefined
```

通过 `=` 赋值运算符为变量赋值

```javascript
var carName = 'chogath';
```

一条语句，多个变量，也可跨行

```javascript
var carName = 'chogath', carName1 = 'chogath1';

var carName2 = 'chogath',
    carName3 = 'chogath3';
```

运算符速查

- [算术运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators)
- [赋值运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Assignment_Operators)
- [按位运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)
- [比较运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)
- [逻辑运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)

### 条件和循环

**条件**

在实际场景中，需要基于不同判断执行不同的动作。

```javascript
if (1 > 0) {
  console.log("1 > 0");
} else if (1 === 0) {
  console.log("1 === 0");
} else {
  console.log("1");
}
// 1 > 0

var x = "0";
switch (x) {
  case 0:
    console.log("Off");
    break;
  case 1:
    console.log("On");
    break;
  default:
    console.log("未找到值");
}
// 未找到值
```

- 使用 `if` 来规定要执行的代码块，如果指定条件为 true。
- 使用 `else` 来规定要执行的代码块，如果相同的条件为 false。
- 使用 `else if` 来规定要测试的新条件，如果上一个条件为 false。
- 使用 `switch` 来规定多个被执行的备选代码块，switch case 使用严格比较（===）。

**循环**

JavaScript 支持不同类型的循环：

```javascript
for (var i = 0; i < 5; i++) {
  console.log("数字是 " + i);
}

var person = { fname:"Bill", lname:"Gates", age:62 }; 
for (var x in person) {
  console.log(person[x]);
}

const array1 = ['a', 'b', 'c'];
for (const element of array1) {
  console.log(element);
}

var i = 0;
while (i < 10) {
  console.log("数字是 " + i);
  i++;
}

var x;
do {
    console.log(x);
    x++;
 }
while (x < 10);
```

- `for` - 多次遍历代码块。
- `for/in` - 遍历对象属性。
- `for/of` - 遍历对象元素。
- `while` - 当指定条件为 true 时循环一段代码块。
- `do/while` - 当指定条件为 true 时循环一段代码块。

> 跳出循环

- `continue` 语句（不论有无标签引用）只能用于跳过一个循环。
- `break` 语句，如果没有标签引用，只能用于跳出一个循环或一个 `switch`。

**标签引用的 demo**

```javascript
list:
{
  console.log(1);
  break list;
  console.log(2);
} // 1
```

## 数据类型

### 对象类型

对象类型也叫引用类型，其中 `Array` 和 `Function` 是 `Object` 的子类型。对象在逻辑上是属性的无序集合，是存放各种值的容器。

### 基础类型

- `String` (字符串)
- `Boolean`（布尔值）
- `Number`（数字）
- `Symbol`（符号）
- `null`（空值）
- `undefined`（未定义）

1. `string`、`number`、`boolean`、`null`、`undefined` 为原始类型，表示不能再细分下去的基本类型。
2. `symbol` 是ES6中新增的数据类型，symbol 表示独一无二的值，通过 `Symbol` 函数调用生成，由于生成的 `symbol` 值为原始类型，所以 `Symbol` 函数不能使用 `new` 调用。

#### 关于 Number 中的 NaN

> NaN 是一个全局对象的属性，是一种特殊的Number类型。

```javascript
Infinity / Infinity;   // 无穷大除以无穷大
Math.sqrt(-1);         // 给任意负数做开方运算

// 算数运算符与不是数字或无法转换为数字的操作数一起使用
'a' - 1;               
'a' * 1;
'a' / 1;

// 字符串解析成数字
parseInt('a');         
parseFloat('a');

Number('a');   // NaN
'abc' - 1      // NaN
undefined + 1  // NaN
+'abc'         // NaN
-'abc'         // NaN
```

根据上面的 🌰，我们可以得出返回NaN的规律：

- 当无穷大除以无穷大
- 当给任意负数做开方运算
- 当算数运算符与不是数字或无法转换为数字的操作数一起使用
- 当无法转换的字符串解析成数字

#### 关于 null 与 undefined

> null 不是一个对象

**null** 不是一个对象，是一个空对象指针，尽管 typeof **null** 输出的是 Object。

这是一个历史遗留问题，JavaScript 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，存储信息中 000 开头代表是对象，**null** 表示为全零，所以 JavaScript 引擎将它错误的判断为 Object。

> 先有 null 后有 undefined，设计 undefined 是为了填补之前的坑。

1995年 JavaScript 诞生时，最初像 Java 一样，只设置了 null 作为表示 "无" 的值。根据C语言的传统，null 被设计成可以自动转为0。

但是 JavaScript 的设计者，觉得这样做还不够，主要有以下两个原因：

1. null 像在 Java 里一样，被当成一个对象。但是作者觉得表示 "无" 的值最好不是对象。
2. JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。作者觉得，如果 null 自动转为0，很不容易发现错误。
因此，作者又设计了一个数据类型，即 undefined。

> null 与 undefined 的区别

- **null** 是一个表示 "无" 的空对象指针，转为数值时为0。
- **undefined** 是一个表示 "无" 的原始值，转为数值时为NaN。

### 类型判断

**typeof**

```javascript
typeof 'chogath'    // 'string'
typeof true        // 'boolean'
typeof 10          // 'number'
typeof Symbol()    // 'symbol'
typeof null        // 'object' 无法判定是否为 null
typeof undefined   // 'undefined'

typeof {}           // 'object'
typeof []           // 'object'
typeof(() => {})    // 'function'
```

> typeof 的不足

- null 的判定有误差，得到的结果 如果使用 typeof，null得到的结果是object
- 操作符对对象类型及其子类型，例如函数（可调用对象）、数组（有序索引对象）等进行判定，则除了函数都会得到 object 的结果。

**instanceof**

通过 instanceof 操作符也可以对对象类型进行判定，其原理就是测试构造函数的 prototype 是否出现在被检测对象的原型链上。

```javascript
[] instanceof Array            // true
({}) instanceof Object         // true
(()=>{}) instanceof Function   // true
```

> 不足

```javascript
let arr = []
let obj = {}
arr instanceof Array    // true
arr instanceof Object   // true
obj instanceof Object   // true
```

在这个实例中：arr.`__proto__` === Array.prototype === Array.prototype.`__proto__` === Object.prototype，因此 Object 构造函数在 arr 的原型链上。所以 instanceof 仍然无法优雅的判断一个值到底属于数组还是普通对象。

**Object.prototype.toString**

> 该方法在传入任何类型的值都能返回对应准确的对象类型，null 和 undefined 能够输出结果是因为 JavaScript 引擎做了解析处理

```javascript
Object.prototype.toString.call({})              // '[object Object]'
Object.prototype.toString.call([])              // '[object Array]'
Object.prototype.toString.call(() => {})        // '[object Function]'
Object.prototype.toString.call('seymoe')        // '[object String]'
Object.prototype.toString.call(1)               // '[object Number]'
Object.prototype.toString.call(true)            // '[object Boolean]'
Object.prototype.toString.call(Symbol())        // '[object Symbol]'
Object.prototype.toString.call(null)            // '[object Null]'
Object.prototype.toString.call(undefined)       // '[object Undefined]'

Object.prototype.toString.call(new Date())      // '[object Date]'
Object.prototype.toString.call(Math)            // '[object Math]'
Object.prototype.toString.call(new Set())       // '[object Set]'
Object.prototype.toString.call(new WeakSet())   // '[object WeakSet]'
Object.prototype.toString.call(new Map())       // '[object Map]'
Object.prototype.toString.call(new WeakMap())   // '[object WeakMap]'
```

## 内存分配

### 变量赋值

#### 基本类型

> 基本类型值: undefined, null, Boolean, String, Number, Symbol 赋值后，在内存中占据固定大小，保存在栈内存中（不包含闭包中的变量）

![var_stack](../../assets/image/var_stack.png)

#### 对象/引用类型

> 对象/引用类型保存在堆内存中。而栈内存存储的是对象的变量标识符,以及对象在堆内存中的存储地址(引用)，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

![var_heap](../../assets/image/var_heap.png)

#### 闭包内的变量

> 闭包中的变量并不保存在栈内存中，而是保存在堆内存中。

```javascript
function d() {
  var a = 'chogath';

  return function() {
    console.log(a);
  }
}
```

伴随着闭包 d 的调用，为了保证变量 a 不被销毁，**javascript** 引擎会在检索闭包局部作用域后生成一个内部对象，将 a 作为内存对象的属性来存储。

![var_closure](../../assets/image/var_closure.png)

### 变量拷贝

#### 基础类型-拷贝

> 在栈内存中的变量发生拷贝行为时，**javascript** 引擎会自动为新的变量分配一个独立的栈内存空间，栈空间内存储的是具体的值，两个变量相互独立，互不影响。

```javascript
var a ='chogath';
var b = a;
```

![copy_01](../../assets/image/copy_01.png)

```javascript
b = 'chogath-other'；
console.log(a); // chogath
```

![copy_02](../../assets/image/copy_02.png)

#### 对象/引用类型-浅拷贝

> 在栈内存中的变量发生拷贝行为时，**javascript** 引擎会自动为新的变量分配一个独立的栈内存空间，栈空间内存储的是对象在堆空间的地址指针，两个变量依赖同一个堆空间

```javascript
let a = { name: 'chogath', age: 8 };
let b = a;
```

![copy_03](../../assets/image/copy_03.png)

```javascript
b.name = 'chogath-other';
console.log(a.name); // chogath-other
```

![copy_04](../../assets/image/copy_04.png)

#### 对象/引用类型-深拷贝

> 从堆内存中开辟一个新的区域存放新对象，新对象跟原对象不共享内存地址指针，修改新对象不会改到原对象。

**JSON.parse(JSON.stringify(object)) 的 🌰**

```javascript
let arr1 = [1, 2, { name: 'chogath' }];
let arr2 = JSON.parse(JSON.stringify(arr1));

arr2[2].name = 'new_chogath'; 

console.log(arr1);// [ 1, 2, { username: 'chogath' } ]
console.log(arr2);// [ 1, 2, { username: 'new_chogath' } ]
```

**JSON.parse(JSON.stringify(object)) 的不足**

- 拷贝的对象的值中如果有**函数**, **undefined**, **symbol**，则经过 **JSON.stringify()** 序列化后的 JSON 字符串中这个键值对会消失
- 无法拷贝不可枚举的属性，无法拷贝对象的原型链
- 拷贝**Date**引用类型会变成字符串
- 拷贝**RegExp**引用类型会变成空对象
- 对象中含有**NaN**、**Infinity** 和 **-Infinity**，则序列化的结果会变成 **null**
- 无法拷贝对象的循环引用(即 **obj[key] = obj**)

**只能实现对对象基础类型属性进行深拷贝的方法**

- `...`（es6 扩展运算符）
- Object.prototype.create
- Array.prototype.slice
- Array.prototype.concat

> 举例

```javascript
const a = [{a: 1}, 2];
b = [...a, 3];

b[0].a = 2;
console.log(b[0].a); // 2
console.log(a[0].a); // 2

b[1] = 3;
console.log(b[1]); // 3
console.log(a[1]); // 2
```

**完全实现深拷贝的几种方式**

> 递归循环

```javascript
function deepClone(item){
  const target = item.constructor === Array ? [] : {};
  for (let keys in item) { // 遍历目标
    if (item.hasOwnProperty(keys)){
      if (item[keys] && typeof item[keys] === 'object') {
        target[keys] = item[keys].constructor === Array ? [] : {};
        target[keys] = deepClone(item[keys]);
      } else {
        target[keys] = item[keys];
      }
    }
  }
  return target;
}

const obj1 = { a:'a', b:'b' };
const obj2 = deepClone(obj1);

obj2.a = 'aa';

console.log(obj1); // { a:'a',b:'b' };
console.log(obj2); // { a:'aa',b:'b' };

const obj3 = {
  name:'chogath',
  fn: function() {
    console.log('Hello World');
  }
}
console.log(obj3); // { name: "chogath", fn: ƒ }
const obj4 = deepClone(obj3);
console.log(obj4); // { name: "chogath", fn: ƒ }
```

> es6 Array.from **(推荐)**

```javascript
var arr1 = [1,2,3];
var arr2 = Array.from(arr1);
arr1.push(4);
console.log(arr1);  //[1,2,3,4]
console.log(arr2);  //[1,2,3,]
arr2.push(5);
console.log(arr1);  //[1,2,3,4]
console.log(arr2);  //[1,2,3,5]
```

> 第三方库，如：lodash.cloneDeep **(推荐)**

```javascript
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);
```

## 隐式转换

> **隐式转换** 指源码中没有明显的类型转换代码，也就是说，一个变量可以直接赋值字符串，也可以直接赋值数值，还可以直接让字符串类型的变量和数值类型的变量相加。

在 JavaScript 中涉及到隐式转换的场景，大多是 JavaScript 引擎在解析运算时产生的。而隐式转换主要是通过

- 将值转为原始值，ToPrimitive()。
- 运算前，将值转为数字类型，Number()。
- 运算前，将值转为字符类型，String()。
- 运算前，将值转为布尔类型，Boolean()。

### 原始值转换

> 隐式转换主要是通过 JavaScript 引擎内部的抽象操作 ToPrimitive 来实现的

```javascript
ToPrimitive(input, PreferredType)
```

- `input` 是要转换的值，PreferredType 是可选参数。
- `PreferredType` 只是一个转换标志，转化后的结果不一定是 PreferredType 对应的类型，但是转换结果一定是一个原始类型的值。

**如果 PreferredType 被标记为 Number**

1. 如果输入的值已经是一个原始值，则直接返回它
2. 否则，如果输入的值是一个对象，则调用该对象的 valueOf() 方法，如果 valueOf() 方法的返回值是一个原始值，直接返回。
3. 否则，调用这个对象的 toString() 方法，如果 toString() 方法返回的是一个原始值，直接返回。
4. 否则，抛出 TypeError 异常。

**如果 PreferredType 被标记为 String**

1. 如果输入的值已经是一个原始值，则直接返回它
2. 否则，调用这个对象的 toString() 方法，如果 toString() 方法返回的是一个原始值，直接返回。
3. 否则，如果输入的值是一个对象，则调用该对象的 valueOf() 方法，如果 valueOf() 方法的返回值是一个原始值，直接返回。
4. 否则，抛出 TypeError 异常。

**如果没有 PreferredType**

1. 该对象为 Date 类型，则 PreferredType 被设置为 String，并执行上面的逻辑。
2. 否则，PreferredType 被设置为 Number，并执行上面的逻辑。

### valueOf 和 toString

> valueOf 和 toString 是顶级对象 Object 的原型方法，所有对象都会继承该原型，故任何对象都会有 valueOf 和 toString 方法。

#### valueOf

**Number、Boolean、String 这三种构造函数生成的基础值的对象形式，通过valueOf转换后会变成相应的原始值**

```javascript
var num = new Number('123'); // 123
num.valueOf(); 

var str = new String('12df');
str.valueOf(); // '12df'

var bool = new Boolean('fd');
bool.valueOf(); // true
```

**Date这种特殊的对象，其原型Date.prototype上内置的valueOf函数将日期转换为日期的毫秒的形式的数值。**

```javascript
new Date().valueOf(); // 1515143895500
```

**除此之外都返回对象本身**

```javascript
var a = new Array();
a.valueOf() === a; // true

var b = new Object({});
b.valueOf() === b; // true
```

#### toString

**Number、Boolean、String、Array、Date、RegExp、Function 这几种构造函数生成的对象，通过 toString 转换后会变成相应的字符串的形式，因为这些构造函数上封装了自己的 toString 方法。如：**

```javascript
Number.prototype.hasOwnProperty('toString'); // true
Boolean.prototype.hasOwnProperty('toString'); // true
String.prototype.hasOwnProperty('toString'); // true
Array.prototype.hasOwnProperty('toString'); // true
Date.prototype.hasOwnProperty('toString'); // true
RegExp.prototype.hasOwnProperty('toString'); // true
Function.prototype.hasOwnProperty('toString'); // true

var num = newNumber('123sd');
num.toString(); // 'NaN'

var str = newString('12df');
str.toString(); // '12df'

var bool = newBoolean('fd');
bool.toString(); // 'true'

var arr = newArray(1,2);
arr.toString(); // '1,2'

var d = newDate();
d.toString(); // "Wed Oct 11 2017 08:00:00 GMT+0800 (中国标准时间)"

var func = function () {}
func.toString(); // "function () {}"
```

**除这些对象及其实例化对象之外，其他对象返回的都是该对象的类型，(都是继承的Object.prototype.toString方法)**

```javascript
var obj = new Object({});

obj.toString(); // "[object Object]"

Math.toString(); // "[object Math]"
```

### 涉及 Number 的运算

- null 转换为 0
- undefined 转换为 NaN
- true 转换为 1，false 转换为 0
- 字符串转换时遵循数字常量规则，转换失败返回 NaN
- 对象则先调用 ToPrimitive 进行原始值转换，type 指定为 number。

> 在什么的场景进行运算，会自动转换为 Number 类型？

**有加法运算符，但是无String类型的时候，都会优先转换为Number类型**

```javascript
true + 0 // 1
true + true // 2
true + false //1
```

**除了加法运算符，其他运算符都会把运算自动转成数值。**

```javascript
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN

//一元运算符（注意点）
+'abc' // NaN
-'abc' // NaN
+true // 1
-false // 0
```

**== 抽象相等比较**

1. 如果存在对象，ToPrimitive()type为number进行转换，再进行后面比较

```javascript
var obj1 = {
  valueOf: function() {
      return '1';
  }
}

1 == obj1; // true
//obj1转为原始值，调用obj1.valueOf() 返回原始值'1'，'1'toNumber得到 1 然后比较 1 == 1

[] == ![] // true
//[]作为对象ToPrimitive得到 ''，![]作为boolean转换得到0，'' == 0，转换为 0==0
```

2. 存在 boolean，按照 Number 将 boolean 转换为1或者0，再进行后面比较

```javascript
//3 == 1 false
//0 == 0 true
3 == true // false
'0' == false //true
```

3. 如果x为string，y为number，x转成number进行比较

```javascript
//'0' toNumber()得到 0  
//0 == 0 true
'0' == 0 //true
```

### 涉及 String 的运算

- null 转换为 'null'
- undefined 转换为 undefined
- true 转换为 'true'，false 转换为 'false'
- 数字转换遵循通用规则，极大极小的数字使用指数形式
- 对象则先调用 ToPrimitive 进行原始值转换，type 指定为 string。

```javascript
String(null)                 // 'null'
String(undefined)            // 'undefined'
String(true)                 // 'true'
String(1)                    // '1'
String(-1)                   // '-1'
String(0)                    // '0'
String(-0)                   // '0'
String(Math.pow(1000,10))    // '1e+30'
String(Infinity)             // 'Infinity'
String(-Infinity)            // '-Infinity'
String({})                   // '[object Object]'
String([1,[2,3]])            // '1,2,3'
```

> 在什么的场景进行运算，会自动转换为 String 类型？

**在没有对象的前提下，字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串**

```javascript
'2' + 1 // '21'
'2' + true // "2true"
'2' + false // "2false"
'2' + undefined // "2undefined"
'2' + null // "2null"
```

**与对象做 `+` 运算**

```javascript
var obj2 = {
  toString: function() {
    return 'a';
  }
};

console.log('2' + obj2); // 2a

var obj1 = {
  a: 1,
  b: 2
};

console.log('2'+obj1); // 2[object Object]

//几种特殊对象
'2' + {}; // "2[object Object]"
'2' + []; // "2"
'2' + function (){}; // "2function (){}"
'2' + ['chogath',1]; // 2chogath,1
```

### 涉及 Boolean 的运算

> 除了下述的值转换结果为 false，其他全部为 true

- undefined
- null
- -0
- 0或+0
- NaN
- ''（空字符串）

```javascript
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false

Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```

> 在什么的场景进行运算，会自动转换为 Boolean 类型？


**布尔比较，如：if(obj) , while(obj) 等判断时，或者三元运算符**

```javascript
if ( !undefined
  && !null
  && !0
  && !NaN
  && !''
) {
  console.log('true');
} // true

// 下面两种情况也会转成布尔类型
expression ? true : false
!! expression
```